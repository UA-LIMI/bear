{
  "development": {
    "tasks": [
      {
        "id": 2,
        "title": "Backend Infrastructure Setup",
        "description": "Set up the Node.js/Express backend service with secure environment management, middleware, CORS, health checks, monitoring, rate limiting, and error handling.",
        "details": "Initialize a new Node.js project with Express. Configure middleware for CORS, request parsing, and logging. Implement environment variable management for API keys using dotenv or similar. Add health check endpoints (/healthz, /readyz). Set up request rate limiting and throttling using express-rate-limit. Implement centralized error handling and logging (e.g., winston or pino). Ensure all sensitive data is never exposed in logs. Document API endpoints and environment setup.",
        "testStrategy": "Unit tests for middleware and endpoints. Integration tests for health checks and error handling. Manual verification of environment variable security. Load testing for rate limiting. Automated monitoring of uptime and error rates.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Node.js Project and Install Dependencies",
            "description": "Set up a new Node.js project with Express and install required dependencies such as express, dotenv, cors, express-rate-limit, and a logging library (winston or pino).",
            "dependencies": [],
            "details": "Run `npm init` to create package.json. Install core dependencies using npm. Ensure the project structure is organized for scalability.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure Environment Variable Management",
            "description": "Implement secure environment variable management using dotenv or a similar library to handle sensitive configuration such as API keys.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create a .env file and ensure sensitive data is loaded securely. Validate that environment variables are not exposed in logs or error messages.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Set Up Core Middleware (CORS, Request Parsing, Logging)",
            "description": "Configure middleware for CORS, request body parsing (JSON and URL-encoded), and request logging.",
            "dependencies": [
              "2.1"
            ],
            "details": "Use cors for cross-origin requests, express.json() and express.urlencoded() for parsing, and a logging middleware for request logs.\n<info added on 2025-09-15T20:52:58.585Z>\nCore middleware setup is complete with Express, CORS, Helmet, Morgan logging, and custom request logging. The server successfully starts, and all endpoints function correctly. CORS is properly configured for frontend communication, and security middleware (Helmet) is set up with WebRTC-compatible settings. Request logging includes request IDs for tracing. Environment validation works correctly with proper error messages. Minor improvements needed include centralizing version numbers and making the memory threshold in health checks configurable. Rate limiting middleware remains to be implemented. Testing results confirm that all endpoints respond correctly, the 404 handler works properly, and health checks validate environment, memory, API keys, and process status.\n</info added on 2025-09-15T20:52:58.585Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Health Check Endpoints",
            "description": "Add /healthz and /readyz endpoints to monitor service health and readiness.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create simple GET endpoints that return status and optionally check dependencies (e.g., database connection).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Set Up Rate Limiting and Throttling",
            "description": "Implement request rate limiting and throttling using express-rate-limit to protect against abuse.",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Configure express-rate-limit with appropriate thresholds and error responses. Test for correct enforcement.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Centralized Error Handling",
            "description": "Set up a centralized error handling middleware to catch and process errors consistently across the application.",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Create an error handler that logs errors and returns sanitized responses. Ensure stack traces and sensitive data are not exposed in production.\n<info added on 2025-09-15T21:14:17.013Z>\nTo enhance the existing error handling middleware, we leveraged the Winston logger by making two key adjustments. First, we ensured that error messages are properly logged with stack traces in development environments but sanitized in production to prevent exposure of sensitive data. Second, we integrated the error handling middleware with Morgan to log HTTP requests and errors consistently across the application. This approach saved significant development time by utilizing existing infrastructure and avoiding over-engineering. The key principle applied here was to first assess what functionality already exists in the codebase before deciding what needs to be built.\n</info added on 2025-09-15T21:14:17.013Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Configure Secure Logging",
            "description": "Integrate a logging library (winston or pino) and ensure that logs do not contain sensitive information.",
            "dependencies": [
              "2.1",
              "2.3",
              "2.6"
            ],
            "details": "Set up log levels, output formats, and redact sensitive fields. Test logging for compliance with security requirements.\n<info added on 2025-09-15T21:30:34.312Z>\nWinston logging infrastructure has been successfully implemented with comprehensive security measures including proper sanitization of sensitive data in log outputs. The secure logging system is now operational with appropriate log levels, structured JSON formatting, and field redaction capabilities to prevent exposure of confidential information. Console.log consolidation and standardization work has been strategically moved to Task 8 to maintain better project organization and separation of concerns.\n</info added on 2025-09-15T21:30:34.312Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Document API Endpoints and Environment Setup",
            "description": "Create documentation for all API endpoints, middleware, and environment variable setup.",
            "dependencies": [
              "2.2",
              "2.3",
              "2.4",
              "2.5",
              "2.6",
              "2.7"
            ],
            "details": "Prepare a README or API reference detailing endpoint usage, expected environment variables, and setup instructions.\n<info added on 2025-09-15T21:45:00.904Z>\nThe comprehensive backend standardization has been successfully completed, incorporating key improvements such as centralized logging with Winston, input validation using express-validator, standardized health checks, a robust test suite, and updated documentation. The backend infrastructure is now fully standardized and ready for integration with the AI Gateway. The documentation for API endpoints, middleware, and environment setup has been updated to reflect these changes, ensuring clarity and ease of use for future development and maintenance.\n</info added on 2025-09-15T21:45:00.904Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Vercel AI Gateway Proxy Implementation",
        "description": "Implement secure Express API endpoints for proxying text-based AI requests to Vercel AI Gateway, with auth, key management, logging, and multi-model support.",
        "details": "Create /api/ai-proxy endpoint in Express. Integrate Vercel AI Gateway SDK for authentication and request forwarding. Securely store and rotate API keys in environment variables. Implement request/response logging for audit and debugging. Support multiple AI models via gateway configuration. Add error handling and retry logic for failed requests. Ensure all requests are authenticated and authorized before proxying.\n<info added on 2025-09-15T21:28:33.577Z>\nTo enhance the Express.js backend architecture for the Vercel AI Gateway proxy implementation, consider the following standardization and consolidation strategies:\n\n1. **Logging Standardization**: Ensure all logging is centralized using a structured logger like Winston. Remove any `console.log` statements and replace them with Winston-based logging to maintain consistency and facilitate log aggregation.\n\n2. **Request Parsing Consolidation**: Confirm that only `express.json()` and `express.urlencoded()` are used for request parsing. Document this strategy and consider adding `express-validator` for input validation to enhance security.\n\n3. **Configuration Management**: Enforce a strict policy where all configuration is sourced from a centralized module (e.g., `src/config/env.js`). Use ESLint rules to prevent direct access to `process.env` elsewhere in the codebase.\n\n4. **Middleware Optimization**: Review middleware for redundancy and ensure that each middleware is modular and reusable. Remove any duplicate logging or error handling middleware.\n\n5. **Health Check Standardization**: Align health check endpoints (`/healthz`, `/readyz`, `/live`) with cloud-native standards by returning minimal, machine-readable responses. Use `/status` for detailed diagnostics intended for developers.\n\nThese strategies will improve maintainability, observability, and compatibility with industry standards and orchestration tools.\n</info added on 2025-09-15T21:28:33.577Z>",
        "testStrategy": "Unit and integration tests for proxy endpoint, including auth and error cases. Test key rotation and logging. Verify multi-model support through gateway configuration. Manual testing of request/response flow with real gateway. Automated monitoring for failed requests and retries.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Express API Endpoint Creation",
            "description": "Create the /api/ai-proxy endpoint in Express with proper routing, middleware setup, and request validation for handling AI proxy requests.",
            "dependencies": [],
            "details": "Set up Express router for /api/ai-proxy endpoint. Implement request validation middleware to validate incoming AI requests (prompt, model, parameters). Add CORS configuration for frontend integration. Create request parsing logic for different content types. Implement basic endpoint structure with proper HTTP method handling (POST). Add request size limits and timeout configurations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Vercel AI Gateway SDK Integration",
            "description": "Integrate the @ai-sdk/gateway package for authentication and request forwarding to Vercel AI Gateway services.",
            "dependencies": [
              "3.1"
            ],
            "details": "Install and configure @ai-sdk/gateway package. Implement gateway provider initialization with custom configuration. Set up generateText and other AI SDK functions for request forwarding. Configure gateway with proper base URL and API key handling. Implement request transformation from Express format to AI SDK format. Add response transformation back to Express-compatible format.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "API Key Management and Rotation",
            "description": "Implement secure storage, retrieval, and rotation of Vercel AI Gateway API keys using environment variables and secure practices.",
            "dependencies": [],
            "details": "Set up environment variable configuration for AI_GATEWAY_API_KEY. Implement secure key loading and validation on application startup. Create key rotation mechanism with graceful fallback. Add key health check functionality to verify API key validity. Implement encrypted storage for backup keys if needed. Add logging for key rotation events without exposing sensitive data.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Request and Response Logging System",
            "description": "Implement comprehensive logging for all AI proxy requests and responses for audit trails and debugging purposes.",
            "dependencies": [
              "3.1"
            ],
            "details": "Set up structured logging with appropriate log levels (info, warn, error). Implement request logging with sanitized data (no sensitive information). Add response logging with status codes and processing times. Create audit trail for all AI model interactions. Implement log rotation and retention policies. Add correlation IDs for request tracking. Include error logging with stack traces and context.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Multi-Model Support Configuration",
            "description": "Implement support for multiple AI models through gateway configuration, allowing dynamic model selection and routing.",
            "dependencies": [
              "3.2"
            ],
            "details": "Create model configuration mapping for supported providers (OpenAI, Anthropic, xAI, Google, Meta, Mistral). Implement dynamic model selection based on request parameters. Add model validation to ensure requested models are available. Create model-specific parameter handling and transformation. Implement fallback logic for unavailable models. Add model usage tracking and statistics.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Error Handling and Retry Logic",
            "description": "Implement robust error handling and retry mechanisms for failed AI Gateway requests with exponential backoff and circuit breaker patterns.",
            "dependencies": [
              "3.2",
              "3.4"
            ],
            "details": "Implement exponential backoff retry logic for transient failures. Add circuit breaker pattern to prevent cascade failures. Create comprehensive error classification (network, API, validation errors). Implement timeout handling for long-running requests. Add rate limiting protection and queue management. Create detailed error responses with appropriate HTTP status codes. Implement retry limits and failure thresholds.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Authentication and Authorization",
            "description": "Implement secure authentication and authorization mechanisms to ensure only authorized requests are proxied to the AI Gateway.",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement JWT token validation middleware for request authentication. Add API key authentication as alternative auth method. Create user authorization checks before proxying requests. Implement rate limiting per authenticated user. Add request origin validation and CORS security. Create audit logging for authentication events. Implement session management and token refresh logic if needed.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "OpenAI Client Secret Generation Endpoint",
        "description": "Build a secure API endpoint for generating ephemeral client secrets for OpenAI real-time voice, with token management, auth, and audit logging.",
        "status": "done",
        "dependencies": [
          2,
          "11"
        ],
        "priority": "high",
        "details": "Implement /api/generate-client-secret endpoint using POST https://api.openai.com/v1/realtime/client_secrets with Bearer authentication. Generate ephemeral keys (ek_...) with expiration timestamps. Integrate with @openai/agents-realtime package RealtimeAgent and RealtimeSession classes. Configure token expiration and refresh logic. Secure endpoint with authentication (e.g., JWT or API key). Log all token generation events for audit. Handle errors and edge cases (e.g., OpenAI API downtime). Reference comprehensive implementation specifications in .taskmaster/docs/research/IMPLEMENTATION_GUIDE.md.",
        "testStrategy": "Unit tests for token generation and expiration logic using exact OpenAI API response format. Integration tests with mocked OpenAI /v1/realtime/client_secrets endpoint. Verify auth and audit logging with ephemeral key tracking. Manual testing of token lifecycle with RealtimeAgent integration. Automated monitoring for token generation failures and ephemeral key validation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API Endpoint Structure",
            "description": "Implement the basic /api/generate-client-secret endpoint with Express.js routing, request validation, and response formatting",
            "status": "done",
            "dependencies": [],
            "details": "Set up Express route handler for POST /api/generate-client-secret. Implement request body validation for required parameters. Define response schema for successful ephemeral token generation (ek_... format) and error cases. Add middleware for CORS, body parsing, and basic request logging. Create endpoint documentation with OpenAPI/Swagger specifications including ephemeral key response format.\n<info added on 2025-09-15T22:14:46.322Z>\nUpdate implementation to use POST /api/client-secret as the endpoint path, following the exact API contract and validation rules specified in .taskmaster/docs/research/IMPLEMENTATION_GUIDE.md:25-45. Integrate rate limiting middleware to prevent abuse and ensure compliance with backend security requirements. Add audit logging for all client secret generation attempts, capturing request metadata and response status for traceability. When handling requests, forward validated payloads to the OpenAI API at POST https://api.openai.com/v1/realtime/client_secrets using Bearer authentication, and return the ephemeral key response in the documented ek_... format. Ensure all error and edge cases are handled according to the research-backed specification.\n</info added on 2025-09-15T22:14:46.322Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "OpenAI API Integration",
            "description": "Integrate with OpenAI's /v1/realtime/client_secrets endpoint to generate ephemeral tokens",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Configure OpenAI SDK with organization API key for Bearer authentication. Implement service layer for calling POST https://api.openai.com/v1/realtime/client_secrets endpoint. Handle OpenAI API response parsing for ephemeral keys (ek_...) and expiration timestamps. Add request timeout and retry logic for OpenAI API calls. Implement proper error mapping from OpenAI responses to client responses. Reference .taskmaster/docs/research/ for exact API specifications.\n<info added on 2025-09-15T22:16:48.904Z>\nImplement the OpenAI API integration using axios for making a POST request to the https://api.openai.com/v1/realtime/client_secrets endpoint with Bearer authentication. Set a request timeout of 10 seconds and implement retry logic for handling transient errors. Ensure proper error handling by mapping OpenAI API responses to client-friendly error messages. Reference the implementation template provided in CODE_TEMPLATES.md for detailed code structure. Additionally, parse the OpenAI API response to extract ephemeral keys (ek_...) and their expiration timestamps, ensuring these are correctly stored and managed within the application.\n</info added on 2025-09-15T22:16:48.904Z>\n<info added on 2025-09-15T22:50:56.414Z>\nCRITICAL LESSON LEARNED: When encountering errors (e.g., session.capabilities parameter format issue), systematically debug the specific parameter or implementation detail rather than questioning the overall architectural approach. The backend proxy pattern for generating ephemeral tokens via the OpenAI /v1/realtime/client_secrets endpoint is confirmed as the correct and standard approach. Implementation is validated with the gpt-4o-realtime-preview model. Always address errors by focused debugging—do not abandon the established plan or research without clear evidence of a fundamental flaw.\n</info added on 2025-09-15T22:50:56.414Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Token Lifecycle Management",
            "description": "Implement ephemeral token expiration tracking, refresh logic, and cleanup mechanisms",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create ephemeral token storage mechanism (in-memory cache or Redis) for tracking active ek_... tokens. Implement token expiration validation using OpenAI-provided timestamps and automatic cleanup. Build refresh logic for tokens nearing expiration. Add token revocation capability for security incidents. Create background job for expired ephemeral token cleanup and metrics collection.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Authentication and Authorization",
            "description": "Secure the endpoint with JWT or API key authentication and implement authorization checks",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement JWT token validation middleware for request authentication. Add API key authentication as alternative auth method. Create user/client authorization checks for ephemeral token generation limits. Implement rate limiting per authenticated user/client. Add role-based access control for different token types or permissions.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Audit Logging System",
            "description": "Implement comprehensive audit logging for all ephemeral token generation events and security monitoring",
            "status": "done",
            "dependencies": [
              2,
              4
            ],
            "details": "Create structured logging for all ephemeral token generation requests and responses including ek_... token IDs. Log authentication events, failures, and security violations. Implement audit trail with user identification, timestamps, and request metadata. Add log aggregation and monitoring alerts for suspicious activity. Create audit log retention and archival policies for ephemeral token tracking.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Error Handling and Edge Cases",
            "description": "Implement robust error handling for OpenAI API downtime, network issues, and other edge cases",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Add circuit breaker pattern for OpenAI /v1/realtime/client_secrets API failures. Implement graceful degradation when OpenAI service is unavailable. Handle network timeouts, connection errors, and malformed responses from ephemeral token endpoint. Add health check endpoint for monitoring service status. Create fallback mechanisms and user-friendly error messages for all failure scenarios.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "RealtimeAgent Integration",
            "description": "Integrate generated ephemeral tokens with @openai/agents-realtime package RealtimeAgent and RealtimeSession classes",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Import and configure @openai/agents-realtime package. Implement RealtimeAgent initialization using generated ephemeral tokens (ek_...). Configure RealtimeSession with proper token lifecycle management. Add token refresh handling within RealtimeAgent context. Create helper functions for seamless integration between backend token generation and frontend realtime agent usage. Reference research documentation for exact integration patterns.",
            "testStrategy": "Unit tests for RealtimeAgent initialization with ephemeral tokens. Integration tests for token refresh within active sessions. Manual testing of realtime voice functionality with generated tokens. Verify proper cleanup when tokens expire during active sessions."
          }
        ]
      },
      {
        "id": 5,
        "title": "Frontend Voice Connection UI",
        "description": "Develop the Next.js frontend voice interface with connection controls, status indicators, and error feedback using shadcn/ui components.",
        "details": "Create a new Next.js 14 page with shadcn/ui for UI components. Implement connect/disconnect buttons. Show real-time connection status (disconnected/connecting/connected). Add visual feedback for active sessions and connection quality. Display error states clearly. Ensure UI is minimal and intuitive. Handle microphone permission requests. Integrate with backend for initial setup.",
        "testStrategy": "Component unit tests with React Testing Library. Manual UI/UX testing for connection flow and error states. Cross-browser testing (Chrome, Firefox, Safari, Edge). Accessibility testing. Automated visual regression testing.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Next.js 14 Page with Shadcn UI",
            "description": "Create a new Next.js 14 page and integrate Shadcn UI for UI components.",
            "dependencies": [],
            "details": "Use Shadcn UI components for a minimal and intuitive UI.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Connection Controls",
            "description": "Add connect/disconnect buttons using Shadcn UI components.",
            "dependencies": [
              "5.1"
            ],
            "details": "Ensure buttons are responsive and accessible.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Real-Time Status Indicators",
            "description": "Show real-time connection status (disconnected/connecting/connected) and add visual feedback for active sessions and connection quality.",
            "dependencies": [
              "5.2"
            ],
            "details": "Use Shadcn UI components for status indicators.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle Microphone Permissions and Error Feedback",
            "description": "Implement microphone permission requests and display error states clearly.",
            "dependencies": [
              "5.3"
            ],
            "details": "Ensure error messages are clear and actionable.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate with Backend for Initial Setup",
            "description": "Integrate the frontend with the backend for initial setup and connection management.",
            "dependencies": [
              "5.4"
            ],
            "details": "Use API calls to synchronize UI with backend events.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "WebRTC Voice Connection Logic",
        "description": "Implement client-side WebRTC voice connection to OpenAI using ephemeral tokens, with state management, reconnection, and cleanup.",
        "details": "Retrieve client secret from backend endpoint. Initialize OpenAI Agents SDK with the token. Set up WebRTC for low-latency audio streaming to OpenAI. Manage connection state (connecting, connected, disconnected). Implement automatic reconnection on drop. Handle microphone setup and permissions. Clean up resources on disconnect. Ensure no API keys are exposed client-side.",
        "testStrategy": "Unit tests for connection state management. Integration tests with mocked backend and OpenAI services. Manual testing of voice latency and reconnection. Automated monitoring for connection failures. Cross-browser compatibility testing.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Retrieve Ephemeral Client Secret",
            "description": "Fetch a short-lived client secret from the backend endpoint for secure OpenAI WebRTC authentication.",
            "dependencies": [],
            "details": "Implement API call to backend /api/generate-client-secret. Handle loading, error, and success states. Ensure the secret is never exposed in logs or client-side storage.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Initialize OpenAI Agents SDK",
            "description": "Configure and initialize the OpenAI Agents SDK client-side using the retrieved ephemeral token.",
            "dependencies": [
              "6.1"
            ],
            "details": "Pass the client secret to the SDK initialization logic. Validate SDK readiness and handle initialization errors. Ensure no API keys are exposed client-side.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "WebRTC Connection Setup",
            "description": "Establish a WebRTC peer connection for low-latency audio streaming to OpenAI.",
            "dependencies": [
              "6.2"
            ],
            "details": "Create RTCPeerConnection, configure ICE servers, and set up SDP offer/answer exchange with OpenAI's /v1/realtime endpoint. Add local audio track from microphone. Initialize DataChannel for event signaling.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Connection State Management",
            "description": "Track and manage WebRTC connection state (connecting, connected, disconnected).",
            "dependencies": [
              "6.3"
            ],
            "details": "Implement state machine for connection lifecycle. Emit events for UI feedback. Synchronize state with global app state management.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Automatic Reconnection Logic",
            "description": "Detect connection drops and automatically attempt reconnection with backoff.",
            "dependencies": [
              "6.4"
            ],
            "details": "Monitor connection health. On failure, clean up existing resources, retrieve a new client secret, and reinitialize the connection. Implement exponential backoff to avoid flooding.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Microphone Setup and Permissions",
            "description": "Handle microphone access, permissions, and audio stream management.",
            "dependencies": [
              "6.3"
            ],
            "details": "Request user microphone permission. Handle denial and retry logic. Manage audio stream lifecycle, ensuring proper cleanup on disconnect.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Resource Cleanup and Security Validation",
            "description": "Ensure proper cleanup of WebRTC resources and validate no sensitive data is exposed.",
            "dependencies": [
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Release media tracks, close peer connections, and clean up event listeners on disconnect. Audit client-side code and network traffic to confirm no API keys or secrets are exposed.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Frontend-Backend Integration & State Management",
        "description": "Integrate frontend with backend APIs, implement error handling, loading states, and connection status synchronization.",
        "details": "Create API client in Next.js for backend communication (e.g., using axios or fetch). Implement global state management (e.g., Zustand or Context API) for connection status. Handle authentication flow if required. Show loading states during API calls. Implement robust error handling and user feedback. Synchronize UI with backend connection events.",
        "testStrategy": "Unit tests for API client and state management. Integration tests for end-to-end connection flow. Manual testing of error and loading states. Automated monitoring for API failures. Cross-browser testing.",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "API Client Implementation",
            "description": "Create a centralized API client service in Next.js for backend communication with proper configuration, interceptors, and request/response handling.",
            "dependencies": [],
            "details": "Set up axios or fetch-based API client with base URL configuration, request/response interceptors for authentication tokens, error handling, and timeout management. Create typed interfaces for API responses. Implement retry logic for failed requests. Configure environment-specific endpoints.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Global State Management Setup",
            "description": "Implement global state management solution for connection status, user data, and application state using Zustand or Context API.",
            "dependencies": [
              "7.1"
            ],
            "details": "Set up Zustand store or React Context for managing connection status, authentication state, and API loading states. Create typed state interfaces and actions. Implement state persistence for user preferences. Add state selectors and hooks for component consumption.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Authentication Flow Integration",
            "description": "Implement complete authentication flow with token management, automatic refresh, and secure storage.",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create authentication service with login/logout functionality. Implement JWT token storage in httpOnly cookies or secure localStorage. Add automatic token refresh logic. Create protected route components and authentication guards. Handle authentication errors and redirects.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Loading States and UI Feedback",
            "description": "Implement comprehensive loading states, progress indicators, and user feedback components throughout the application.",
            "dependencies": [
              "7.2"
            ],
            "details": "Create reusable loading components (spinners, skeletons, progress bars). Implement global loading state management. Add loading overlays for API calls. Create toast notifications for success/error feedback. Implement optimistic UI updates where appropriate.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Error Handling and User Feedback",
            "description": "Build robust error handling system with user-friendly error messages, retry mechanisms, and fallback UI components.",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create centralized error handling service with error categorization. Implement user-friendly error messages and recovery suggestions. Add error boundaries for React components. Create retry mechanisms for failed API calls. Implement offline detection and appropriate UI feedback.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Backend Event Synchronization",
            "description": "Implement real-time synchronization between frontend UI and backend connection events using WebSocket or Server-Sent Events.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3"
            ],
            "details": "Set up WebSocket or SSE connection for real-time updates. Implement event listeners for connection status changes. Create UI components that react to backend events. Handle connection drops and reconnection logic. Implement heartbeat mechanism for connection health monitoring.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Consolidate Logging System with Winston Logger",
        "description": "Replace all console.log statements with Winston logger and integrate Winston requestLogger middleware for consistent logging across the application.",
        "details": "1. **Remove Console Logs**: Replace all `console.log` statements in `app.js` with Winston logger calls. Ensure that sensitive data is not logged. 2. **Configure Winston Logger**: Set up a shared Winston logger instance in `logger.js` with appropriate log levels and transports (e.g., console, file). 3. **Integrate RequestLogger Middleware**: Use the Winston requestLogger middleware from `logger.js` to log incoming requests and responses in Express routes. 4. **Ensure Consistency**: Verify that all middleware and routes use the shared Winston logger for structured logging. 5. **Test Logging**: Validate that logs are correctly written to designated transports without exposing sensitive information.",
        "testStrategy": "1. **Unit Tests**: Write unit tests to verify that console logs are replaced and Winston logs are correctly generated. 2. **Integration Tests**: Test that the requestLogger middleware logs requests and responses as expected. 3. **Manual Verification**: Check log files and console output for consistency and absence of sensitive data. 4. **Load Testing**: Perform load testing to ensure logging does not impact performance.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Add Input Validation with express-validator",
        "description": "Implement request validation middleware using express-validator for all API endpoints that accept user input, ensuring enhanced security and data quality.",
        "details": "Integrate express-validator middleware to validate and sanitize all incoming request data for endpoints that process user input, such as /api/ai-proxy and /api/generate-client-secret. Define validation rules for each field (e.g., required, format, length, custom patterns) using express-validator's chainable API. For example, validate that API keys are non-empty strings, email fields match email format, and passwords meet complexity requirements. Sanitize inputs to prevent injection and normalize data (e.g., trim whitespace, normalize email case). Centralize error handling to return structured validation error responses (field-by-field details) in a consistent format. Ensure validation is applied before any business logic or external API calls. Document all validation rules and error responses for frontend integration. Example implementation for a registration endpoint:\n\n```js\napp.post('/register', [\n  body('name').notEmpty().trim().isLength({ min: 2, max: 50 }),\n  body('email').notEmpty().isEmail().normalizeEmail(),\n  body('password').notEmpty().isLength({ min: 8 })\n    .matches(/[A-Z]/).matches(/[0-9]/)\n], (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  // Proceed if validation passes\n});\n```\nExtend this pattern to all relevant endpoints, ensuring no user input bypasses validation. Consider creating a reusable validation middleware utility if multiple endpoints share similar rules[2][3].",
        "testStrategy": "Write unit tests for each validation rule to verify correct acceptance and rejection of input values. Perform integration tests by sending requests with valid and invalid data to each endpoint, ensuring the API rejects invalid requests with appropriate error messages and status codes. Test edge cases such as empty fields, malformed data, and injection attempts. Verify that sanitization (e.g., trimming, email normalization) is applied correctly. Check that error responses are consistent and actionable for frontend consumption. Include automated tests in CI/CD to catch regressions. Manual testing with tools like Postman or curl to confirm real-world behavior. Document test cases and expected outcomes for QA review[2][3].",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Standardize Health Check Endpoints",
        "description": "Refactor health check endpoints to align with cloud-native standards, providing minimal machine-readable responses for /healthz, /readyz, and /live, while reserving detailed diagnostics for /status. Clearly document endpoint semantics.",
        "details": "Implement standardized health check endpoints in the Express backend to support cloud-native monitoring and orchestration tools. /healthz should return a minimal JSON response (e.g., {\"status\": \"ok\"}) with HTTP 200 if the application is generally healthy, and a non-200 status if not. /readyz should indicate readiness to accept traffic (e.g., {\"ready\": true}), returning HTTP 200 only when all critical dependencies (database, external services) are reachable. /live should return a minimal response (e.g., {\"alive\": true}) with HTTP 200 as long as the process is running, regardless of dependency health. Detailed diagnostic information (e.g., dependency status, metrics, configuration) should be moved to a separate /status endpoint, which is intended for internal use only. Update API documentation to clearly explain the purpose, semantics, and expected responses for each endpoint, following cloud-native conventions[1][2]. Ensure all endpoints are secured and do not expose sensitive information. Consider adding response time metrics to /healthz if relevant for your monitoring setup.",
        "testStrategy": "Write unit tests to verify each endpoint returns the correct HTTP status and minimal JSON payload under various conditions (e.g., healthy, unhealthy, dependencies down). For /readyz, simulate dependency failures (e.g., database disconnect) and verify the endpoint reflects the correct readiness state. For /live, ensure it always returns 200 while the process is running. For /status, verify it returns detailed diagnostics only when accessed internally. Perform integration tests with monitoring tools to confirm they can parse and act on the machine-readable responses. Test security by verifying that /status is not publicly accessible if sensitive. Update documentation tests to ensure all endpoint semantics are clearly and accurately described.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "OpenAI Realtime API Knowledge Base Creation",
        "description": "Research, organize, and document all official OpenAI Agents SDK and Realtime API sources from September 2025, creating comprehensive reference documentation for integration teams.",
        "details": "Create a structured knowledge base in .taskmaster/docs/research/ with clear sections for each major integration area. Research and summarize the latest official OpenAI documentation, SDKs, and API references, focusing on: 1) Client secret generation endpoints and authentication (including /v1/realtime/client_secrets, token management, and audit logging), 2) WebRTC vs WebSocket transport mechanisms (pros, cons, and implementation patterns), 3) RealtimeAgent and RealtimeSession configuration (initialization, state management, and lifecycle), 4) Audio processing and microphone setup (direct audio streaming, encoding, and device handling), 5) Error handling and connection management (timeouts, retries, and recovery), 6) Model configuration and streaming (model selection, streaming parameters, and performance tuning), 7) Tools integration (remote MCP servers, SIP calling, image input), 8) Context management (session state, conversation history, and multimodal context), 9) Session lifecycle and interruption handling (pause, resume, and graceful termination).\n\nFor each section, provide concise explanations, code snippets (e.g., WebSocket setup, session initialization, error handling), configuration examples, and links to official sources. Highlight differences between traditional voice AI pipelines and the new direct speech-to-speech processing of gpt-realtime, emphasizing latency, fidelity, and development complexity[1][3]. Document new features such as image input, SIP support, reusable prompts, and enterprise compliance (e.g., EU Data Residency)[1][2]. Include best practices for production deployment, such as monitoring, logging, and scalability considerations. Store all findings in markdown files with a consistent structure, ensuring the knowledge base is easily navigable and referenceable by all integration teams.",
        "testStrategy": "Verify completeness and accuracy by cross-referencing each documentation section with the latest official OpenAI sources and SDKs. Conduct peer reviews with integration engineers to ensure clarity, technical correctness, and practical relevance. Test code snippets and configuration examples in a sandbox environment to confirm they work as described. Validate that the knowledge base covers all requested topics and edge cases (e.g., API downtime, session interruption, multimodal context loss). Ensure that the documentation is stored in the correct directory structure and is accessible to the team. Use automated checks (e.g., markdown linting, dead link detection) to maintain quality. Update the knowledge base as new official sources or SDK updates are released.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "OpenAI Agents SDK Models Guide Extraction",
            "description": "Research and document all relevant implementation details from the OpenAI Agents SDK Models Guide, focusing on model selection, initialization, configuration, and integration patterns for realtime agents.",
            "dependencies": [],
            "details": "Summarize supported models, configuration parameters, and initialization flows. Include code snippets for agent instantiation and model switching. Highlight differences between gpt-realtime and previous models, especially regarding direct speech-to-speech capabilities and latency improvements.\n<info added on 2025-09-15T22:11:50.917Z>\nSupported models for the OpenAI Realtime API currently include gpt-realtime and gpt-4-realtime (also referenced as gpt-4o-realtime-preview in some implementations)[1][2]. These models are designed specifically for low-latency, bidirectional audio streaming and real-time conversational interactions, distinguishing them from previous GPT models that primarily handled text-based, request-response patterns.\n\nConfiguration parameters for RealtimeAgent and RealtimeSession include the model name (e.g., model=\"gpt-4o-realtime-preview\"), API key, base URL, and optional settings such as verbose logging[2]. The API supports WebSocket as the primary transport for real-time audio and event streaming, with no direct mention of WebRTC in the current official integration patterns—WebRTC may be used in custom client-side audio handling but is not part of the core OpenAI Realtime API transport[1][2]. Key session configuration options include instructions for the agent, voice selection, audio transcription model, and turn detection (e.g., server-side voice activity detection)[3]. Additional parameters like temperature and reasoning.effort can be set to influence response creativity and processing depth, though their exact implementation may vary by SDK.\n\nInitialization typically involves creating a WebSocket connection to the OpenAI endpoint with authentication headers, then managing the session lifecycle for sending and receiving audio and events[2]. Below is a minimal Python example for agent instantiation and model switching:\n\n```python\nclass RealtimeApiConnection:\n    def __init__(self, base_uri, api_key=None, model=\"gpt-4o-realtime-preview\"):\n        self.url = f\"{base_uri}/v1/realtime?model={model}\"\n        self.api_key = api_key\n        self.websocket = None\n        self.session = aiohttp.ClientSession()\n\n    async def connect(self):\n        auth = aiohttp.BasicAuth(\"\", self.api_key) if self.api_key else None\n        headers = {\"OpenAI-Beta\": \"realtime=v1\"}\n        self.websocket = await self.session.ws_connect(self.url, auth=auth, headers=headers)\n\n    async def close(self):\n        if self.websocket:\n            await self.websocket.close()\n            self.websocket = None\n```\nTo switch models, update the model parameter in the connection URL during initialization[2].\n\nThe gpt-realtime and gpt-4-realtime models introduce direct speech-to-speech capabilities, enabling real-time audio input and output streaming over WebSocket, with the API managing conversation state, turn-taking, and interruptions seamlessly[1]. This is a significant departure from previous models, which required separate audio processing pipelines and suffered from higher end-to-end latency. The new models also support function calling in real time, with events for streaming function call arguments and completion, though the full function call must be assembled before execution[1]. Audio is transmitted as base64-encoded chunks, supporting uncompressed 16-bit, 24kHz audio (nominal bitrate ~384 kbps, ~500 kbps with base64 overhead, reduced with compression)[1]. The API handles phrase endpointing (turn detection) server-side, further reducing client complexity and latency compared to client-side solutions[1][3].\n\nIn summary, the OpenAI Realtime API and its supported models enable a new class of low-latency, voice-first applications with simplified integration, direct audio streaming, and improved conversational dynamics over previous text-centric GPT models.\n</info added on 2025-09-15T22:11:50.917Z>",
            "status": "done",
            "testStrategy": "Cross-reference extracted details with official SDK documentation and test agent initialization code for correctness."
          },
          {
            "id": 2,
            "title": "Tools Integration Guide Documentation",
            "description": "Extract and document integration steps and best practices from the Tools Integration Guide, with emphasis on remote MCP server setup, SIP calling, and image input.",
            "dependencies": [],
            "details": "Provide configuration examples for MCP server integration, SIP endpoint setup, and image input handling. Include payload structures, authentication requirements, and tool invocation patterns. Document reusable prompt setup and tool approval workflows.",
            "status": "pending",
            "testStrategy": "Validate integration steps by simulating tool calls and verifying correct API responses and session behavior."
          },
          {
            "id": 3,
            "title": "Streaming Guide Implementation Reference",
            "description": "Summarize and document streaming protocols, focusing on WebRTC and WebSocket transport mechanisms, their pros and cons, and implementation patterns from the Streaming Guide.",
            "dependencies": [],
            "details": "Compare WebRTC and WebSocket for audio streaming, including setup, latency, reliability, and scalability. Provide code snippets for both transports. Highlight recommended use cases and fallback strategies.",
            "status": "pending",
            "testStrategy": "Test both transport mechanisms in sample applications and measure latency, connection stability, and error handling."
          },
          {
            "id": 4,
            "title": "AI SDK Extensions Feature Extraction",
            "description": "Research and document AI SDK Extensions, focusing on advanced configuration, extensibility, and custom session management for realtime agents.",
            "dependencies": [],
            "details": "Detail extension points, hooks, and custom middleware for session lifecycle, context management, and multimodal input. Include code examples for extending agent capabilities and integrating with external services.",
            "status": "pending",
            "testStrategy": "Implement and test custom extensions in a controlled environment, ensuring compatibility with core SDK features."
          },
          {
            "id": 5,
            "title": "Voice Agents Quickstart Documentation",
            "description": "Extract step-by-step setup and initialization instructions from the Voice Agents Quickstart, focusing on rapid prototyping and minimal configuration for realtime voice agents.",
            "dependencies": [],
            "details": "Document prerequisites, environment setup, and minimal code to launch a realtime voice agent. Include microphone setup, audio streaming, and session start/stop flows. Highlight common pitfalls and troubleshooting tips.",
            "status": "done",
            "testStrategy": "Follow the quickstart steps in a clean environment and verify successful agent deployment and audio streaming."
          },
          {
            "id": 6,
            "title": "Voice Agents Overview Summary",
            "description": "Summarize the high-level architecture, capabilities, and use cases of OpenAI voice agents from the Voice Agents Overview documentation.",
            "dependencies": [],
            "details": "Provide an overview of the realtime voice agent pipeline, key features (e.g., direct speech-to-speech, low latency, multimodal input), and supported deployment scenarios. Compare with traditional voice AI pipelines.",
            "status": "pending",
            "testStrategy": "Review overview content with integration engineers to ensure clarity and alignment with technical documentation."
          },
          {
            "id": 7,
            "title": "Context Management Guide Extraction",
            "description": "Document session state, conversation history, and multimodal context handling from the Context Management Guide.",
            "dependencies": [],
            "details": "Summarize APIs and patterns for managing session context, storing and retrieving conversation history, and handling multimodal (audio, image, text) context. Include code snippets for context updates and retrieval.",
            "status": "pending",
            "testStrategy": "Test context management flows in sample sessions, verifying state persistence and context-aware responses."
          },
          {
            "id": 8,
            "title": "Realtime API Platform Docs Reference",
            "description": "Extract and document all official endpoints, authentication flows, error handling, and production best practices from the Realtime API Platform Docs.",
            "dependencies": [],
            "details": "Detail client secret generation (/v1/realtime/client_secrets), token management, audit logging, error handling, and connection management. Include configuration examples, monitoring, logging, and scalability recommendations.",
            "status": "done",
            "testStrategy": "Test endpoint flows and error scenarios in a sandbox environment, ensuring documentation matches observed API behavior."
          },
          {
            "id": 9,
            "title": "Realtime WebRTC Platform Docs Extraction",
            "description": "Summarize WebRTC-specific setup, configuration, and troubleshooting steps from the Realtime WebRTC Platform Docs.",
            "dependencies": [],
            "details": "Document WebRTC signaling, ICE server configuration, audio encoding, and device handling. Include code snippets for establishing and managing WebRTC connections. Highlight differences from WebSocket transport.",
            "status": "done",
            "testStrategy": "Implement WebRTC connection flows using documented steps and verify successful audio streaming and session management."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-15T20:02:22.697Z",
      "updated": "2025-09-15T23:22:44.316Z",
      "description": "Tasks for development context"
    }
  },
  "feature-task-finalization": {
    "tasks": [
      {
        "id": 2,
        "title": "Backend Infrastructure Setup",
        "description": "Set up the Node.js/Express backend service with secure environment management, middleware, CORS, health checks, monitoring, rate limiting, and error handling.",
        "details": "Initialize a new Node.js project with Express. Configure middleware for CORS, request parsing, and logging. Implement environment variable management for API keys using dotenv or similar. Add health check endpoints (/healthz, /readyz). Set up request rate limiting and throttling using express-rate-limit. Implement centralized error handling and logging (e.g., winston or pino). Ensure all sensitive data is never exposed in logs. Document API endpoints and environment setup.",
        "testStrategy": "Unit tests for middleware and endpoints. Integration tests for health checks and error handling. Manual verification of environment variable security. Load testing for rate limiting. Automated monitoring of uptime and error rates.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Node.js Project and Install Dependencies",
            "description": "Set up a new Node.js project with Express and install required dependencies such as express, dotenv, cors, express-rate-limit, and a logging library (winston or pino).",
            "dependencies": [],
            "details": "Run `npm init` to create package.json. Install core dependencies using npm. Ensure the project structure is organized for scalability.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure Environment Variable Management",
            "description": "Implement secure environment variable management using dotenv or a similar library to handle sensitive configuration such as API keys.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create a .env file and ensure sensitive data is loaded securely. Validate that environment variables are not exposed in logs or error messages.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Set Up Core Middleware (CORS, Request Parsing, Logging)",
            "description": "Configure middleware for CORS, request body parsing (JSON and URL-encoded), and request logging.",
            "dependencies": [
              "2.1"
            ],
            "details": "Use cors for cross-origin requests, express.json() and express.urlencoded() for parsing, and a logging middleware for request logs.\n<info added on 2025-09-15T20:52:58.585Z>\nCore middleware setup is complete with Express, CORS, Helmet, Morgan logging, and custom request logging. The server successfully starts, and all endpoints function correctly. CORS is properly configured for frontend communication, and security middleware (Helmet) is set up with WebRTC-compatible settings. Request logging includes request IDs for tracing. Environment validation works correctly with proper error messages. Minor improvements needed include centralizing version numbers and making the memory threshold in health checks configurable. Rate limiting middleware remains to be implemented. Testing results confirm that all endpoints respond correctly, the 404 handler works properly, and health checks validate environment, memory, API keys, and process status.\n</info added on 2025-09-15T20:52:58.585Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Health Check Endpoints",
            "description": "Add /healthz and /readyz endpoints to monitor service health and readiness.",
            "dependencies": [
              "2.1"
            ],
            "details": "Create simple GET endpoints that return status and optionally check dependencies (e.g., database connection).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Set Up Rate Limiting and Throttling",
            "description": "Implement request rate limiting and throttling using express-rate-limit to protect against abuse.",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Configure express-rate-limit with appropriate thresholds and error responses. Test for correct enforcement.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Centralized Error Handling",
            "description": "Set up a centralized error handling middleware to catch and process errors consistently across the application.",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Create an error handler that logs errors and returns sanitized responses. Ensure stack traces and sensitive data are not exposed in production.\n<info added on 2025-09-15T21:14:17.013Z>\nTo enhance the existing error handling middleware, we leveraged the Winston logger by making two key adjustments. First, we ensured that error messages are properly logged with stack traces in development environments but sanitized in production to prevent exposure of sensitive data. Second, we integrated the error handling middleware with Morgan to log HTTP requests and errors consistently across the application. This approach saved significant development time by utilizing existing infrastructure and avoiding over-engineering. The key principle applied here was to first assess what functionality already exists in the codebase before deciding what needs to be built.\n</info added on 2025-09-15T21:14:17.013Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Configure Secure Logging",
            "description": "Integrate a logging library (winston or pino) and ensure that logs do not contain sensitive information.",
            "dependencies": [
              "2.1",
              "2.3",
              "2.6"
            ],
            "details": "Set up log levels, output formats, and redact sensitive fields. Test logging for compliance with security requirements.\n<info added on 2025-09-15T21:30:34.312Z>\nWinston logging infrastructure has been successfully implemented with comprehensive security measures including proper sanitization of sensitive data in log outputs. The secure logging system is now operational with appropriate log levels, structured JSON formatting, and field redaction capabilities to prevent exposure of confidential information. Console.log consolidation and standardization work has been strategically moved to Task 8 to maintain better project organization and separation of concerns.\n</info added on 2025-09-15T21:30:34.312Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Document API Endpoints and Environment Setup",
            "description": "Create documentation for all API endpoints, middleware, and environment variable setup.",
            "dependencies": [
              "2.2",
              "2.3",
              "2.4",
              "2.5",
              "2.6",
              "2.7"
            ],
            "details": "Prepare a README or API reference detailing endpoint usage, expected environment variables, and setup instructions.\n<info added on 2025-09-15T21:45:00.904Z>\nThe comprehensive backend standardization has been successfully completed, incorporating key improvements such as centralized logging with Winston, input validation using express-validator, standardized health checks, a robust test suite, and updated documentation. The backend infrastructure is now fully standardized and ready for integration with the AI Gateway. The documentation for API endpoints, middleware, and environment setup has been updated to reflect these changes, ensuring clarity and ease of use for future development and maintenance.\n</info added on 2025-09-15T21:45:00.904Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Vercel AI Gateway Proxy Implementation",
        "description": "Implement secure Express API endpoints for proxying text-based AI requests to Vercel AI Gateway, with auth, key management, logging, and multi-model support.",
        "details": "Create /api/ai-proxy endpoint in Express. Integrate Vercel AI Gateway SDK for authentication and request forwarding. Securely store and rotate API keys in environment variables. Implement request/response logging for audit and debugging. Support multiple AI models via gateway configuration. Add error handling and retry logic for failed requests. Ensure all requests are authenticated and authorized before proxying.\n<info added on 2025-09-15T21:28:33.577Z>\nTo enhance the Express.js backend architecture for the Vercel AI Gateway proxy implementation, consider the following standardization and consolidation strategies:\n\n1. **Logging Standardization**: Ensure all logging is centralized using a structured logger like Winston. Remove any `console.log` statements and replace them with Winston-based logging to maintain consistency and facilitate log aggregation.\n\n2. **Request Parsing Consolidation**: Confirm that only `express.json()` and `express.urlencoded()` are used for request parsing. Document this strategy and consider adding `express-validator` for input validation to enhance security.\n\n3. **Configuration Management**: Enforce a strict policy where all configuration is sourced from a centralized module (e.g., `src/config/env.js`). Use ESLint rules to prevent direct access to `process.env` elsewhere in the codebase.\n\n4. **Middleware Optimization**: Review middleware for redundancy and ensure that each middleware is modular and reusable. Remove any duplicate logging or error handling middleware.\n\n5. **Health Check Standardization**: Align health check endpoints (`/healthz`, `/readyz`, `/live`) with cloud-native standards by returning minimal, machine-readable responses. Use `/status` for detailed diagnostics intended for developers.\n\nThese strategies will improve maintainability, observability, and compatibility with industry standards and orchestration tools.\n</info added on 2025-09-15T21:28:33.577Z>",
        "testStrategy": "Unit and integration tests for proxy endpoint, including auth and error cases. Test key rotation and logging. Verify multi-model support through gateway configuration. Manual testing of request/response flow with real gateway. Automated monitoring for failed requests and retries.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Express API Endpoint Creation",
            "description": "Create the /api/ai-proxy endpoint in Express with proper routing, middleware setup, and request validation for handling AI proxy requests.",
            "dependencies": [],
            "details": "Set up Express router for /api/ai-proxy endpoint. Implement request validation middleware to validate incoming AI requests (prompt, model, parameters). Add CORS configuration for frontend integration. Create request parsing logic for different content types. Implement basic endpoint structure with proper HTTP method handling (POST). Add request size limits and timeout configurations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Vercel AI Gateway SDK Integration",
            "description": "Integrate the @ai-sdk/gateway package for authentication and request forwarding to Vercel AI Gateway services.",
            "dependencies": [
              "3.1"
            ],
            "details": "Install and configure @ai-sdk/gateway package. Implement gateway provider initialization with custom configuration. Set up generateText and other AI SDK functions for request forwarding. Configure gateway with proper base URL and API key handling. Implement request transformation from Express format to AI SDK format. Add response transformation back to Express-compatible format.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "API Key Management and Rotation",
            "description": "Implement secure storage, retrieval, and rotation of Vercel AI Gateway API keys using environment variables and secure practices.",
            "dependencies": [],
            "details": "Set up environment variable configuration for AI_GATEWAY_API_KEY. Implement secure key loading and validation on application startup. Create key rotation mechanism with graceful fallback. Add key health check functionality to verify API key validity. Implement encrypted storage for backup keys if needed. Add logging for key rotation events without exposing sensitive data.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Request and Response Logging System",
            "description": "Implement comprehensive logging for all AI proxy requests and responses for audit trails and debugging purposes.",
            "dependencies": [
              "3.1"
            ],
            "details": "Set up structured logging with appropriate log levels (info, warn, error). Implement request logging with sanitized data (no sensitive information). Add response logging with status codes and processing times. Create audit trail for all AI model interactions. Implement log rotation and retention policies. Add correlation IDs for request tracking. Include error logging with stack traces and context.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Multi-Model Support Configuration",
            "description": "Implement support for multiple AI models through gateway configuration, allowing dynamic model selection and routing.",
            "dependencies": [
              "3.2"
            ],
            "details": "Create model configuration mapping for supported providers (OpenAI, Anthropic, xAI, Google, Meta, Mistral). Implement dynamic model selection based on request parameters. Add model validation to ensure requested models are available. Create model-specific parameter handling and transformation. Implement fallback logic for unavailable models. Add model usage tracking and statistics.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Error Handling and Retry Logic",
            "description": "Implement robust error handling and retry mechanisms for failed AI Gateway requests with exponential backoff and circuit breaker patterns.",
            "dependencies": [
              "3.2",
              "3.4"
            ],
            "details": "Implement exponential backoff retry logic for transient failures. Add circuit breaker pattern to prevent cascade failures. Create comprehensive error classification (network, API, validation errors). Implement timeout handling for long-running requests. Add rate limiting protection and queue management. Create detailed error responses with appropriate HTTP status codes. Implement retry limits and failure thresholds.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Authentication and Authorization",
            "description": "Implement secure authentication and authorization mechanisms to ensure only authorized requests are proxied to the AI Gateway.",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement JWT token validation middleware for request authentication. Add API key authentication as alternative auth method. Create user authorization checks before proxying requests. Implement rate limiting per authenticated user. Add request origin validation and CORS security. Create audit logging for authentication events. Implement session management and token refresh logic if needed.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "OpenAI Client Secret Generation Endpoint",
        "description": "Build a secure API endpoint for generating ephemeral client secrets for OpenAI real-time voice, with token management, auth, and audit logging.",
        "status": "done",
        "dependencies": [
          2,
          "11"
        ],
        "priority": "high",
        "details": "Implement /api/generate-client-secret endpoint using POST https://api.openai.com/v1/realtime/client_secrets with Bearer authentication. Generate ephemeral keys (ek_...) with expiration timestamps. Integrate with @openai/agents-realtime package RealtimeAgent and RealtimeSession classes. Configure token expiration and refresh logic. Secure endpoint with authentication (e.g., JWT or API key). Log all token generation events for audit. Handle errors and edge cases (e.g., OpenAI API downtime). Reference comprehensive implementation specifications in .taskmaster/docs/research/IMPLEMENTATION_GUIDE.md.",
        "testStrategy": "Unit tests for token generation and expiration logic using exact OpenAI API response format. Integration tests with mocked OpenAI /v1/realtime/client_secrets endpoint. Verify auth and audit logging with ephemeral key tracking. Manual testing of token lifecycle with RealtimeAgent integration. Automated monitoring for token generation failures and ephemeral key validation.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create API Endpoint Structure",
            "description": "Implement the basic /api/generate-client-secret endpoint with Express.js routing, request validation, and response formatting",
            "status": "done",
            "dependencies": [],
            "details": "Set up Express route handler for POST /api/generate-client-secret. Implement request body validation for required parameters. Define response schema for successful ephemeral token generation (ek_... format) and error cases. Add middleware for CORS, body parsing, and basic request logging. Create endpoint documentation with OpenAPI/Swagger specifications including ephemeral key response format.\n<info added on 2025-09-15T22:14:46.322Z>\nUpdate implementation to use POST /api/client-secret as the endpoint path, following the exact API contract and validation rules specified in .taskmaster/docs/research/IMPLEMENTATION_GUIDE.md:25-45. Integrate rate limiting middleware to prevent abuse and ensure compliance with backend security requirements. Add audit logging for all client secret generation attempts, capturing request metadata and response status for traceability. When handling requests, forward validated payloads to the OpenAI API at POST https://api.openai.com/v1/realtime/client_secrets using Bearer authentication, and return the ephemeral key response in the documented ek_... format. Ensure all error and edge cases are handled according to the research-backed specification.\n</info added on 2025-09-15T22:14:46.322Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "OpenAI API Integration",
            "description": "Integrate with OpenAI's /v1/realtime/client_secrets endpoint to generate ephemeral tokens",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Configure OpenAI SDK with organization API key for Bearer authentication. Implement service layer for calling POST https://api.openai.com/v1/realtime/client_secrets endpoint. Handle OpenAI API response parsing for ephemeral keys (ek_...) and expiration timestamps. Add request timeout and retry logic for OpenAI API calls. Implement proper error mapping from OpenAI responses to client responses. Reference .taskmaster/docs/research/ for exact API specifications.\n<info added on 2025-09-15T22:16:48.904Z>\nImplement the OpenAI API integration using axios for making a POST request to the https://api.openai.com/v1/realtime/client_secrets endpoint with Bearer authentication. Set a request timeout of 10 seconds and implement retry logic for handling transient errors. Ensure proper error handling by mapping OpenAI API responses to client-friendly error messages. Reference the implementation template provided in CODE_TEMPLATES.md for detailed code structure. Additionally, parse the OpenAI API response to extract ephemeral keys (ek_...) and their expiration timestamps, ensuring these are correctly stored and managed within the application.\n</info added on 2025-09-15T22:16:48.904Z>\n<info added on 2025-09-15T22:50:56.414Z>\nCRITICAL LESSON LEARNED: When encountering errors (e.g., session.capabilities parameter format issue), systematically debug the specific parameter or implementation detail rather than questioning the overall architectural approach. The backend proxy pattern for generating ephemeral tokens via the OpenAI /v1/realtime/client_secrets endpoint is confirmed as the correct and standard approach. Implementation is validated with the gpt-4o-realtime-preview model. Always address errors by focused debugging—do not abandon the established plan or research without clear evidence of a fundamental flaw.\n</info added on 2025-09-15T22:50:56.414Z>",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Token Lifecycle Management",
            "description": "Implement ephemeral token expiration tracking, refresh logic, and cleanup mechanisms",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create ephemeral token storage mechanism (in-memory cache or Redis) for tracking active ek_... tokens. Implement token expiration validation using OpenAI-provided timestamps and automatic cleanup. Build refresh logic for tokens nearing expiration. Add token revocation capability for security incidents. Create background job for expired ephemeral token cleanup and metrics collection.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Authentication and Authorization",
            "description": "Secure the endpoint with JWT or API key authentication and implement authorization checks",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Implement JWT token validation middleware for request authentication. Add API key authentication as alternative auth method. Create user/client authorization checks for ephemeral token generation limits. Implement rate limiting per authenticated user/client. Add role-based access control for different token types or permissions.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Audit Logging System",
            "description": "Implement comprehensive audit logging for all ephemeral token generation events and security monitoring",
            "status": "done",
            "dependencies": [
              2,
              4
            ],
            "details": "Create structured logging for all ephemeral token generation requests and responses including ek_... token IDs. Log authentication events, failures, and security violations. Implement audit trail with user identification, timestamps, and request metadata. Add log aggregation and monitoring alerts for suspicious activity. Create audit log retention and archival policies for ephemeral token tracking.",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Error Handling and Edge Cases",
            "description": "Implement robust error handling for OpenAI API downtime, network issues, and other edge cases",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Add circuit breaker pattern for OpenAI /v1/realtime/client_secrets API failures. Implement graceful degradation when OpenAI service is unavailable. Handle network timeouts, connection errors, and malformed responses from ephemeral token endpoint. Add health check endpoint for monitoring service status. Create fallback mechanisms and user-friendly error messages for all failure scenarios.",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "RealtimeAgent Integration",
            "description": "Integrate generated ephemeral tokens with @openai/agents-realtime package RealtimeAgent and RealtimeSession classes",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "Import and configure @openai/agents-realtime package. Implement RealtimeAgent initialization using generated ephemeral tokens (ek_...). Configure RealtimeSession with proper token lifecycle management. Add token refresh handling within RealtimeAgent context. Create helper functions for seamless integration between backend token generation and frontend realtime agent usage. Reference research documentation for exact integration patterns.",
            "testStrategy": "Unit tests for RealtimeAgent initialization with ephemeral tokens. Integration tests for token refresh within active sessions. Manual testing of realtime voice functionality with generated tokens. Verify proper cleanup when tokens expire during active sessions."
          }
        ]
      },
      {
        "id": 5,
        "title": "Frontend Voice Connection UI",
        "description": "Develop the Next.js frontend voice interface with connection controls, status indicators, and error feedback using shadcn/ui components.",
        "details": "Create a new Next.js 14 page with shadcn/ui for UI components. Implement connect/disconnect buttons. Show real-time connection status (disconnected/connecting/connected). Add visual feedback for active sessions and connection quality. Display error states clearly. Ensure UI is minimal and intuitive. Handle microphone permission requests. Integrate with backend for initial setup.",
        "testStrategy": "Component unit tests with React Testing Library. Manual UI/UX testing for connection flow and error states. Cross-browser testing (Chrome, Firefox, Safari, Edge). Accessibility testing. Automated visual regression testing.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Next.js 14 Page with Shadcn UI",
            "description": "Create a new Next.js 14 page and integrate Shadcn UI for UI components.",
            "dependencies": [],
            "details": "Use Shadcn UI components for a minimal and intuitive UI.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Connection Controls",
            "description": "Add connect/disconnect buttons using Shadcn UI components.",
            "dependencies": [
              "5.1"
            ],
            "details": "Ensure buttons are responsive and accessible.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Real-Time Status Indicators",
            "description": "Show real-time connection status (disconnected/connecting/connected) and add visual feedback for active sessions and connection quality.",
            "dependencies": [
              "5.2"
            ],
            "details": "Use Shadcn UI components for status indicators.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle Microphone Permissions and Error Feedback",
            "description": "Implement microphone permission requests and display error states clearly.",
            "dependencies": [
              "5.3"
            ],
            "details": "Ensure error messages are clear and actionable.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate with Backend for Initial Setup",
            "description": "Integrate the frontend with the backend for initial setup and connection management.",
            "dependencies": [
              "5.4"
            ],
            "details": "Use API calls to synchronize UI with backend events.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "WebRTC Voice Connection Logic",
        "description": "Implement client-side WebRTC voice connection to OpenAI using ephemeral tokens, with state management, reconnection, and cleanup.",
        "details": "Retrieve client secret from backend endpoint. Initialize OpenAI Agents SDK with the token. Set up WebRTC for low-latency audio streaming to OpenAI. Manage connection state (connecting, connected, disconnected). Implement automatic reconnection on drop. Handle microphone setup and permissions. Clean up resources on disconnect. Ensure no API keys are exposed client-side.",
        "testStrategy": "Unit tests for connection state management. Integration tests with mocked backend and OpenAI services. Manual testing of voice latency and reconnection. Automated monitoring for connection failures. Cross-browser compatibility testing.",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Retrieve Ephemeral Client Secret",
            "description": "Fetch a short-lived client secret from the backend endpoint for secure OpenAI WebRTC authentication.",
            "dependencies": [],
            "details": "Implement API call to backend /api/generate-client-secret. Handle loading, error, and success states. Ensure the secret is never exposed in logs or client-side storage.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Initialize OpenAI Agents SDK",
            "description": "Configure and initialize the OpenAI Agents SDK client-side using the retrieved ephemeral token.",
            "dependencies": [
              "6.1"
            ],
            "details": "Pass the client secret to the SDK initialization logic. Validate SDK readiness and handle initialization errors. Ensure no API keys are exposed client-side.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "WebRTC Connection Setup",
            "description": "Establish a WebRTC peer connection for low-latency audio streaming to OpenAI.",
            "dependencies": [
              "6.2"
            ],
            "details": "Create RTCPeerConnection, configure ICE servers, and set up SDP offer/answer exchange with OpenAI's /v1/realtime endpoint. Add local audio track from microphone. Initialize DataChannel for event signaling.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Connection State Management",
            "description": "Track and manage WebRTC connection state (connecting, connected, disconnected).",
            "dependencies": [
              "6.3"
            ],
            "details": "Implement state machine for connection lifecycle. Emit events for UI feedback. Synchronize state with global app state management.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Automatic Reconnection Logic",
            "description": "Detect connection drops and automatically attempt reconnection with backoff.",
            "dependencies": [
              "6.4"
            ],
            "details": "Monitor connection health. On failure, clean up existing resources, retrieve a new client secret, and reinitialize the connection. Implement exponential backoff to avoid flooding.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Microphone Setup and Permissions",
            "description": "Handle microphone access, permissions, and audio stream management.",
            "dependencies": [
              "6.3"
            ],
            "details": "Request user microphone permission. Handle denial and retry logic. Manage audio stream lifecycle, ensuring proper cleanup on disconnect.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Resource Cleanup and Security Validation",
            "description": "Ensure proper cleanup of WebRTC resources and validate no sensitive data is exposed.",
            "dependencies": [
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Release media tracks, close peer connections, and clean up event listeners on disconnect. Audit client-side code and network traffic to confirm no API keys or secrets are exposed.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Frontend-Backend Integration & State Management",
        "description": "Integrate frontend with backend APIs, implement error handling, loading states, and connection status synchronization.",
        "details": "Create API client in Next.js for backend communication (e.g., using axios or fetch). Implement global state management (e.g., Zustand or Context API) for connection status. Handle authentication flow if required. Show loading states during API calls. Implement robust error handling and user feedback. Synchronize UI with backend connection events.",
        "testStrategy": "Unit tests for API client and state management. Integration tests for end-to-end connection flow. Manual testing of error and loading states. Automated monitoring for API failures. Cross-browser testing.",
        "priority": "medium",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "API Client Implementation",
            "description": "Create a centralized API client service in Next.js for backend communication with proper configuration, interceptors, and request/response handling.",
            "dependencies": [],
            "details": "Set up axios or fetch-based API client with base URL configuration, request/response interceptors for authentication tokens, error handling, and timeout management. Create typed interfaces for API responses. Implement retry logic for failed requests. Configure environment-specific endpoints.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Global State Management Setup",
            "description": "Implement global state management solution for connection status, user data, and application state using Zustand or Context API.",
            "dependencies": [
              "7.1"
            ],
            "details": "Set up Zustand store or React Context for managing connection status, authentication state, and API loading states. Create typed state interfaces and actions. Implement state persistence for user preferences. Add state selectors and hooks for component consumption.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Authentication Flow Integration",
            "description": "Implement complete authentication flow with token management, automatic refresh, and secure storage.",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create authentication service with login/logout functionality. Implement JWT token storage in httpOnly cookies or secure localStorage. Add automatic token refresh logic. Create protected route components and authentication guards. Handle authentication errors and redirects.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Loading States and UI Feedback",
            "description": "Implement comprehensive loading states, progress indicators, and user feedback components throughout the application.",
            "dependencies": [
              "7.2"
            ],
            "details": "Create reusable loading components (spinners, skeletons, progress bars). Implement global loading state management. Add loading overlays for API calls. Create toast notifications for success/error feedback. Implement optimistic UI updates where appropriate.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Error Handling and User Feedback",
            "description": "Build robust error handling system with user-friendly error messages, retry mechanisms, and fallback UI components.",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Create centralized error handling service with error categorization. Implement user-friendly error messages and recovery suggestions. Add error boundaries for React components. Create retry mechanisms for failed API calls. Implement offline detection and appropriate UI feedback.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Backend Event Synchronization",
            "description": "Implement real-time synchronization between frontend UI and backend connection events using WebSocket or Server-Sent Events.",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3"
            ],
            "details": "Set up WebSocket or SSE connection for real-time updates. Implement event listeners for connection status changes. Create UI components that react to backend events. Handle connection drops and reconnection logic. Implement heartbeat mechanism for connection health monitoring.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Consolidate Logging System with Winston Logger",
        "description": "Replace all console.log statements with Winston logger and integrate Winston requestLogger middleware for consistent logging across the application.",
        "details": "1. **Remove Console Logs**: Replace all `console.log` statements in `app.js` with Winston logger calls. Ensure that sensitive data is not logged. 2. **Configure Winston Logger**: Set up a shared Winston logger instance in `logger.js` with appropriate log levels and transports (e.g., console, file). 3. **Integrate RequestLogger Middleware**: Use the Winston requestLogger middleware from `logger.js` to log incoming requests and responses in Express routes. 4. **Ensure Consistency**: Verify that all middleware and routes use the shared Winston logger for structured logging. 5. **Test Logging**: Validate that logs are correctly written to designated transports without exposing sensitive information.",
        "testStrategy": "1. **Unit Tests**: Write unit tests to verify that console logs are replaced and Winston logs are correctly generated. 2. **Integration Tests**: Test that the requestLogger middleware logs requests and responses as expected. 3. **Manual Verification**: Check log files and console output for consistency and absence of sensitive data. 4. **Load Testing**: Perform load testing to ensure logging does not impact performance.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Add Input Validation with express-validator",
        "description": "Implement request validation middleware using express-validator for all API endpoints that accept user input, ensuring enhanced security and data quality.",
        "details": "Integrate express-validator middleware to validate and sanitize all incoming request data for endpoints that process user input, such as /api/ai-proxy and /api/generate-client-secret. Define validation rules for each field (e.g., required, format, length, custom patterns) using express-validator's chainable API. For example, validate that API keys are non-empty strings, email fields match email format, and passwords meet complexity requirements. Sanitize inputs to prevent injection and normalize data (e.g., trim whitespace, normalize email case). Centralize error handling to return structured validation error responses (field-by-field details) in a consistent format. Ensure validation is applied before any business logic or external API calls. Document all validation rules and error responses for frontend integration. Example implementation for a registration endpoint:\n\n```js\napp.post('/register', [\n  body('name').notEmpty().trim().isLength({ min: 2, max: 50 }),\n  body('email').notEmpty().isEmail().normalizeEmail(),\n  body('password').notEmpty().isLength({ min: 8 })\n    .matches(/[A-Z]/).matches(/[0-9]/)\n], (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  // Proceed if validation passes\n});\n```\nExtend this pattern to all relevant endpoints, ensuring no user input bypasses validation. Consider creating a reusable validation middleware utility if multiple endpoints share similar rules[2][3].",
        "testStrategy": "Write unit tests for each validation rule to verify correct acceptance and rejection of input values. Perform integration tests by sending requests with valid and invalid data to each endpoint, ensuring the API rejects invalid requests with appropriate error messages and status codes. Test edge cases such as empty fields, malformed data, and injection attempts. Verify that sanitization (e.g., trimming, email normalization) is applied correctly. Check that error responses are consistent and actionable for frontend consumption. Include automated tests in CI/CD to catch regressions. Manual testing with tools like Postman or curl to confirm real-world behavior. Document test cases and expected outcomes for QA review[2][3].",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Standardize Health Check Endpoints",
        "description": "Refactor health check endpoints to align with cloud-native standards, providing minimal machine-readable responses for /healthz, /readyz, and /live, while reserving detailed diagnostics for /status. Clearly document endpoint semantics.",
        "details": "Implement standardized health check endpoints in the Express backend to support cloud-native monitoring and orchestration tools. /healthz should return a minimal JSON response (e.g., {\"status\": \"ok\"}) with HTTP 200 if the application is generally healthy, and a non-200 status if not. /readyz should indicate readiness to accept traffic (e.g., {\"ready\": true}), returning HTTP 200 only when all critical dependencies (database, external services) are reachable. /live should return a minimal response (e.g., {\"alive\": true}) with HTTP 200 as long as the process is running, regardless of dependency health. Detailed diagnostic information (e.g., dependency status, metrics, configuration) should be moved to a separate /status endpoint, which is intended for internal use only. Update API documentation to clearly explain the purpose, semantics, and expected responses for each endpoint, following cloud-native conventions[1][2]. Ensure all endpoints are secured and do not expose sensitive information. Consider adding response time metrics to /healthz if relevant for your monitoring setup.",
        "testStrategy": "Write unit tests to verify each endpoint returns the correct HTTP status and minimal JSON payload under various conditions (e.g., healthy, unhealthy, dependencies down). For /readyz, simulate dependency failures (e.g., database disconnect) and verify the endpoint reflects the correct readiness state. For /live, ensure it always returns 200 while the process is running. For /status, verify it returns detailed diagnostics only when accessed internally. Perform integration tests with monitoring tools to confirm they can parse and act on the machine-readable responses. Test security by verifying that /status is not publicly accessible if sensitive. Update documentation tests to ensure all endpoint semantics are clearly and accurately described.",
        "status": "done",
        "dependencies": [
          2
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "OpenAI Realtime API Knowledge Base Creation",
        "description": "Research, organize, and document all official OpenAI Agents SDK and Realtime API sources from September 2025, creating comprehensive reference documentation for integration teams.",
        "details": "Create a structured knowledge base in .taskmaster/docs/research/ with clear sections for each major integration area. Research and summarize the latest official OpenAI documentation, SDKs, and API references, focusing on: 1) Client secret generation endpoints and authentication (including /v1/realtime/client_secrets, token management, and audit logging), 2) WebRTC vs WebSocket transport mechanisms (pros, cons, and implementation patterns), 3) RealtimeAgent and RealtimeSession configuration (initialization, state management, and lifecycle), 4) Audio processing and microphone setup (direct audio streaming, encoding, and device handling), 5) Error handling and connection management (timeouts, retries, and recovery), 6) Model configuration and streaming (model selection, streaming parameters, and performance tuning), 7) Tools integration (remote MCP servers, SIP calling, image input), 8) Context management (session state, conversation history, and multimodal context), 9) Session lifecycle and interruption handling (pause, resume, and graceful termination).\n\nFor each section, provide concise explanations, code snippets (e.g., WebSocket setup, session initialization, error handling), configuration examples, and links to official sources. Highlight differences between traditional voice AI pipelines and the new direct speech-to-speech processing of gpt-realtime, emphasizing latency, fidelity, and development complexity[1][3]. Document new features such as image input, SIP support, reusable prompts, and enterprise compliance (e.g., EU Data Residency)[1][2]. Include best practices for production deployment, such as monitoring, logging, and scalability considerations. Store all findings in markdown files with a consistent structure, ensuring the knowledge base is easily navigable and referenceable by all integration teams.",
        "testStrategy": "Verify completeness and accuracy by cross-referencing each documentation section with the latest official OpenAI sources and SDKs. Conduct peer reviews with integration engineers to ensure clarity, technical correctness, and practical relevance. Test code snippets and configuration examples in a sandbox environment to confirm they work as described. Validate that the knowledge base covers all requested topics and edge cases (e.g., API downtime, session interruption, multimodal context loss). Ensure that the documentation is stored in the correct directory structure and is accessible to the team. Use automated checks (e.g., markdown linting, dead link detection) to maintain quality. Update the knowledge base as new official sources or SDK updates are released.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "OpenAI Agents SDK Models Guide Extraction",
            "description": "Research and document all relevant implementation details from the OpenAI Agents SDK Models Guide, focusing on model selection, initialization, configuration, and integration patterns for realtime agents.",
            "dependencies": [],
            "details": "Summarize supported models, configuration parameters, and initialization flows. Include code snippets for agent instantiation and model switching. Highlight differences between gpt-realtime and previous models, especially regarding direct speech-to-speech capabilities and latency improvements.\n<info added on 2025-09-15T22:11:50.917Z>\nSupported models for the OpenAI Realtime API currently include gpt-realtime and gpt-4-realtime (also referenced as gpt-4o-realtime-preview in some implementations)[1][2]. These models are designed specifically for low-latency, bidirectional audio streaming and real-time conversational interactions, distinguishing them from previous GPT models that primarily handled text-based, request-response patterns.\n\nConfiguration parameters for RealtimeAgent and RealtimeSession include the model name (e.g., model=\"gpt-4o-realtime-preview\"), API key, base URL, and optional settings such as verbose logging[2]. The API supports WebSocket as the primary transport for real-time audio and event streaming, with no direct mention of WebRTC in the current official integration patterns—WebRTC may be used in custom client-side audio handling but is not part of the core OpenAI Realtime API transport[1][2]. Key session configuration options include instructions for the agent, voice selection, audio transcription model, and turn detection (e.g., server-side voice activity detection)[3]. Additional parameters like temperature and reasoning.effort can be set to influence response creativity and processing depth, though their exact implementation may vary by SDK.\n\nInitialization typically involves creating a WebSocket connection to the OpenAI endpoint with authentication headers, then managing the session lifecycle for sending and receiving audio and events[2]. Below is a minimal Python example for agent instantiation and model switching:\n\n```python\nclass RealtimeApiConnection:\n    def __init__(self, base_uri, api_key=None, model=\"gpt-4o-realtime-preview\"):\n        self.url = f\"{base_uri}/v1/realtime?model={model}\"\n        self.api_key = api_key\n        self.websocket = None\n        self.session = aiohttp.ClientSession()\n\n    async def connect(self):\n        auth = aiohttp.BasicAuth(\"\", self.api_key) if self.api_key else None\n        headers = {\"OpenAI-Beta\": \"realtime=v1\"}\n        self.websocket = await self.session.ws_connect(self.url, auth=auth, headers=headers)\n\n    async def close(self):\n        if self.websocket:\n            await self.websocket.close()\n            self.websocket = None\n```\nTo switch models, update the model parameter in the connection URL during initialization[2].\n\nThe gpt-realtime and gpt-4-realtime models introduce direct speech-to-speech capabilities, enabling real-time audio input and output streaming over WebSocket, with the API managing conversation state, turn-taking, and interruptions seamlessly[1]. This is a significant departure from previous models, which required separate audio processing pipelines and suffered from higher end-to-end latency. The new models also support function calling in real time, with events for streaming function call arguments and completion, though the full function call must be assembled before execution[1]. Audio is transmitted as base64-encoded chunks, supporting uncompressed 16-bit, 24kHz audio (nominal bitrate ~384 kbps, ~500 kbps with base64 overhead, reduced with compression)[1]. The API handles phrase endpointing (turn detection) server-side, further reducing client complexity and latency compared to client-side solutions[1][3].\n\nIn summary, the OpenAI Realtime API and its supported models enable a new class of low-latency, voice-first applications with simplified integration, direct audio streaming, and improved conversational dynamics over previous text-centric GPT models.\n</info added on 2025-09-15T22:11:50.917Z>",
            "status": "done",
            "testStrategy": "Cross-reference extracted details with official SDK documentation and test agent initialization code for correctness."
          },
          {
            "id": 2,
            "title": "Tools Integration Guide Documentation",
            "description": "Extract and document integration steps and best practices from the Tools Integration Guide, with emphasis on remote MCP server setup, SIP calling, and image input.",
            "dependencies": [],
            "details": "Provide configuration examples for MCP server integration, SIP endpoint setup, and image input handling. Include payload structures, authentication requirements, and tool invocation patterns. Document reusable prompt setup and tool approval workflows.",
            "status": "pending",
            "testStrategy": "Validate integration steps by simulating tool calls and verifying correct API responses and session behavior."
          },
          {
            "id": 3,
            "title": "Streaming Guide Implementation Reference",
            "description": "Summarize and document streaming protocols, focusing on WebRTC and WebSocket transport mechanisms, their pros and cons, and implementation patterns from the Streaming Guide.",
            "dependencies": [],
            "details": "Compare WebRTC and WebSocket for audio streaming, including setup, latency, reliability, and scalability. Provide code snippets for both transports. Highlight recommended use cases and fallback strategies.",
            "status": "pending",
            "testStrategy": "Test both transport mechanisms in sample applications and measure latency, connection stability, and error handling."
          },
          {
            "id": 4,
            "title": "AI SDK Extensions Feature Extraction",
            "description": "Research and document AI SDK Extensions, focusing on advanced configuration, extensibility, and custom session management for realtime agents.",
            "dependencies": [],
            "details": "Detail extension points, hooks, and custom middleware for session lifecycle, context management, and multimodal input. Include code examples for extending agent capabilities and integrating with external services.",
            "status": "pending",
            "testStrategy": "Implement and test custom extensions in a controlled environment, ensuring compatibility with core SDK features."
          },
          {
            "id": 5,
            "title": "Voice Agents Quickstart Documentation",
            "description": "Extract step-by-step setup and initialization instructions from the Voice Agents Quickstart, focusing on rapid prototyping and minimal configuration for realtime voice agents.",
            "dependencies": [],
            "details": "Document prerequisites, environment setup, and minimal code to launch a realtime voice agent. Include microphone setup, audio streaming, and session start/stop flows. Highlight common pitfalls and troubleshooting tips.",
            "status": "done",
            "testStrategy": "Follow the quickstart steps in a clean environment and verify successful agent deployment and audio streaming."
          },
          {
            "id": 6,
            "title": "Voice Agents Overview Summary",
            "description": "Summarize the high-level architecture, capabilities, and use cases of OpenAI voice agents from the Voice Agents Overview documentation.",
            "dependencies": [],
            "details": "Provide an overview of the realtime voice agent pipeline, key features (e.g., direct speech-to-speech, low latency, multimodal input), and supported deployment scenarios. Compare with traditional voice AI pipelines.",
            "status": "pending",
            "testStrategy": "Review overview content with integration engineers to ensure clarity and alignment with technical documentation."
          },
          {
            "id": 7,
            "title": "Context Management Guide Extraction",
            "description": "Document session state, conversation history, and multimodal context handling from the Context Management Guide.",
            "dependencies": [],
            "details": "Summarize APIs and patterns for managing session context, storing and retrieving conversation history, and handling multimodal (audio, image, text) context. Include code snippets for context updates and retrieval.",
            "status": "pending",
            "testStrategy": "Test context management flows in sample sessions, verifying state persistence and context-aware responses."
          },
          {
            "id": 8,
            "title": "Realtime API Platform Docs Reference",
            "description": "Extract and document all official endpoints, authentication flows, error handling, and production best practices from the Realtime API Platform Docs.",
            "dependencies": [],
            "details": "Detail client secret generation (/v1/realtime/client_secrets), token management, audit logging, error handling, and connection management. Include configuration examples, monitoring, logging, and scalability recommendations.",
            "status": "done",
            "testStrategy": "Test endpoint flows and error scenarios in a sandbox environment, ensuring documentation matches observed API behavior."
          },
          {
            "id": 9,
            "title": "Realtime WebRTC Platform Docs Extraction",
            "description": "Summarize WebRTC-specific setup, configuration, and troubleshooting steps from the Realtime WebRTC Platform Docs.",
            "dependencies": [],
            "details": "Document WebRTC signaling, ICE server configuration, audio encoding, and device handling. Include code snippets for establishing and managing WebRTC connections. Highlight differences from WebSocket transport.",
            "status": "done",
            "testStrategy": "Implement WebRTC connection flows using documented steps and verify successful audio streaming and session management."
          }
        ]
      },
      {
        "id": 12,
        "title": "Refactor logger.js to Eliminate Circular Dependency via getConfig Function",
        "description": "Resolve the circular dependency in logger.js by replacing direct config imports with a dynamic getConfig function, ensuring proper module initialization and maintainability.",
        "details": "1. **Identify the Circular Dependency**: Analyze logger.js and config.js (or equivalent) to confirm the import cycle, typically caused by each module importing the other directly[3].\n\n2. **Refactor config Access**: In logger.js, remove any direct import of the config object or module. Instead, define and use a `getConfig` function that retrieves configuration values at runtime. This function should be imported from config.js, which must export it independently of any code that imports logger.js.\n\n3. **Update config.js**: Ensure that config.js does not import logger.js or otherwise reference it at the top level. Export the `getConfig` function so that logger.js can safely import and call it without triggering a circular import[3].\n\n4. **Update All Usages**: Replace all references to the config object in logger.js with calls to `getConfig()`. If logger.js needs specific config values, destructure them from the result of `getConfig()`.\n\n5. **Test for Side Effects**: Review initialization order and ensure that no code in either module depends on the other being fully initialized at import time. If necessary, refactor further to decouple logic or move shared utilities to a third module[2][3].\n\n6. **Document the Change**: Add comments explaining the rationale for using `getConfig()` instead of direct imports, referencing the circular dependency issue for future maintainers.",
        "testStrategy": "1. **Automated Tests**: Run the full test suite to ensure no regressions or initialization errors occur after the refactor.\n\n2. **Manual Verification**: Start the application and verify that logging works as expected and configuration values are correctly loaded at runtime.\n\n3. **Static Analysis**: Use a circular dependency detection tool (such as madge or circular-dependency-plugin) to confirm that the logger.js <-> config.js cycle has been eliminated[2].\n\n4. **Edge Case Testing**: Simulate scenarios where config values are loaded late or changed at runtime to ensure logger.js always receives the correct values via getConfig().\n\n5. **Code Review**: Have another developer review the changes to confirm that the circular dependency is resolved and the code remains maintainable.",
        "status": "pending",
        "dependencies": [
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Fix Circular Dependency in aiProxy.js by Refactoring Config Access",
        "description": "Resolve the circular dependency in aiProxy.js by replacing direct config imports with a dynamic getConfig function, ensuring proper module initialization and maintainability.",
        "details": "1. Analyze aiProxy.js and config.js (or equivalent) to confirm the circular import cycle, typically caused by each module importing the other directly.\n\n2. In aiProxy.js, remove any direct import of the config object or module. Instead, import and use a getConfig function that retrieves configuration values at runtime. This function should be exported from config.js independently of any code that imports aiProxy.js, preventing initialization order issues.\n\n3. Refactor any code in aiProxy.js that previously accessed config directly to use getConfig(). For example, replace `const { apiKey } = require('./config')` with `const { getConfig } = require('./config')` and access values via `getConfig().apiKey`.\n\n4. Ensure config.js does not import aiProxy.js or any modules that would reintroduce a cycle. If necessary, move shared logic to a new utility module to decouple dependencies[1][2][3].\n\n5. Run static analysis tools (e.g., madge) to verify the circular dependency is resolved.",
        "testStrategy": "1. Run static analysis (e.g., madge) to confirm the circular dependency between aiProxy.js and config.js is eliminated.\n\n2. Execute the full automated test suite to ensure no regressions or initialization errors occur after the refactor.\n\n3. Manually start the application and verify that aiProxy functionality works as expected and configuration values are correctly loaded at runtime.\n\n4. Review logs and error output for signs of unresolved dependency issues or runtime failures.",
        "status": "pending",
        "dependencies": [
          12
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Verify and Correct Validation Chain Middleware References",
        "description": "Audit all express-validator validation chains across the codebase to ensure each reference points to the correct middleware function and is properly integrated into the request handling flow.",
        "details": "1. Review all API routes and middleware registrations where express-validator is used, focusing on the order and correctness of validation chain references (e.g., body, param, query validators).\n2. Confirm that each validation chain is correctly attached as middleware in the route definition and that the corresponding validation result handler (e.g., a custom validate middleware) is invoked immediately after the validation chain, as recommended in best practices[1][2][3][4].\n3. Identify and fix any instances where validation chains are missing, misordered, or reference the wrong middleware function, which could lead to skipped validation or improper error handling.\n4. Refactor route definitions to ensure a clean and consistent pattern: validation chains first, followed by the validation result handler, then the main controller logic.\n5. Update or create shared validation middleware if necessary to avoid duplication and ensure maintainability.\n6. Document any changes to middleware usage patterns in the project's developer documentation.",
        "testStrategy": "1. Manually inspect all route definitions to verify that validation chains and their result handlers are correctly referenced and ordered.\n2. Write or update automated tests to send requests with both valid and invalid data to each endpoint, confirming that validation errors are consistently caught and reported.\n3. Use static analysis or code search tools to detect any routes missing validation middleware or referencing incorrect functions.\n4. Review application logs and error responses to ensure validation failures are handled as expected and no requests bypass validation unintentionally.",
        "status": "pending",
        "dependencies": [
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Run Comprehensive Test Suite to Verify All Fixes and Middleware Integrations",
        "description": "Execute the full automated and manual test suite to ensure all recent validation middleware corrections and circular dependency refactors function as intended, with no regressions or integration issues.",
        "details": "1. Ensure all code changes from recent validation middleware audits and circular dependency refactors are merged into the test branch.\n2. Run the complete automated test suite, including unit, integration, and end-to-end tests, focusing on:\n   - Validation middleware correctness: Confirm that all express-validator chains and result handlers are properly invoked and errors are handled in a user-friendly, consistent format[1][4][5].\n   - Refactored modules (aiProxy.js, logger.js): Verify that dynamic config access via getConfig functions works as expected and no circular dependencies remain.\n3. For endpoints using express-validator, send requests with both valid and invalid data, confirming that validation errors are caught and returned in the expected structure[1][4].\n4. Manually test critical API flows and edge cases not covered by automation, especially those involving middleware chaining and error handling.\n5. Review test coverage reports to ensure all new and modified code paths are exercised.\n6. Document any test failures, regressions, or unexpected behaviors for immediate triage.",
        "testStrategy": "1. Run 'npm test' or equivalent command to execute all automated tests, ensuring 100% pass rate.\n2. Use tools like madge to confirm no circular dependencies exist in the codebase after refactors.\n3. Manually test API endpoints with various payloads to verify validation middleware and error formatting.\n4. Review CI/CD pipeline results for any failures or warnings.\n5. Validate that all recent fixes (validation chain references, config refactors) are covered by tests and behave as intended in both automated and manual testing.\n6. Summarize results and report any issues for further action before proceeding to deployment or additional development.",
        "status": "pending",
        "dependencies": [
          12,
          13,
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Fix Circular Dependency in rateLimiter.js by Refactoring Config Access",
        "description": "Resolve the circular dependency in rateLimiter.js by replacing direct config imports with a dynamic getConfig function, ensuring proper module initialization and maintainability.",
        "details": "1. Analyze rateLimiter.js and config.js (or equivalent) to confirm the circular import cycle, typically caused by each module importing the other directly.\n\n2. In rateLimiter.js, remove any direct import of the config object or module. Instead, import and use a getConfig function that retrieves configuration values at runtime. This function should be exported from config.js independently of any code that imports rateLimiter.js, preventing initialization order issues.\n\n3. Refactor any code in rateLimiter.js that previously accessed config directly to use getConfig instead. Ensure that getConfig is implemented in a way that does not itself import rateLimiter.js or any modules that would reintroduce the cycle.\n\n4. If necessary, update config.js to decouple its exports, ensuring getConfig is available without triggering circular imports. Consider extracting shared configuration logic into a separate utility module if required[1][2][3].\n\n5. After refactoring, review all usages of rateLimiter.js and config.js to confirm no other circular dependencies exist.",
        "testStrategy": "1. Run static analysis (e.g., madge) to confirm the circular dependency between rateLimiter.js and config.js is eliminated.\n\n2. Execute the full automated test suite to ensure no regressions or initialization errors occur after the refactor.\n\n3. Manually start the application and verify that rate limiting works as expected and configuration values are correctly loaded at runtime.\n\n4. Inspect runtime logs and error reports for any issues related to configuration loading or module initialization.",
        "status": "pending",
        "dependencies": [
          12
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Fix RealtimeSession Disconnect Handling in OpenAI Agents SDK Integration",
        "description": "Investigate and implement the correct disconnect and close method for RealtimeSession objects in the OpenAI Agents SDK to ensure reliable session termination and resource cleanup.",
        "details": "1. **Research the latest OpenAI Agents SDK documentation and code samples** to identify the recommended approach for disconnecting and closing RealtimeSession instances, including any recent changes or deprecations in the SDK API. Focus on both JavaScript and Python SDKs as relevant, referencing the official guides and API docs[2][7].\n\n2. **Analyze current disconnect issues**: Review logs and error messages related to session disconnects, such as unexpected WebSocket closures (e.g., code 1000 or 1011), session expiration, or keepalive timeouts[1][3][4]. Identify whether the disconnects are due to improper session closure, missing cleanup logic, or SDK bugs.\n\n3. **Implement the correct disconnect/close logic**: Update the integration code to use the officially supported method for closing a RealtimeSession (e.g., `session.close()` or equivalent), ensuring all event listeners are removed and resources are released. If the SDK provides asynchronous cleanup or requires awaiting a promise, ensure this is handled properly to avoid race conditions or memory leaks[2][7].\n\n4. **Handle edge cases**: Add logic to gracefully handle server-initiated disconnects (e.g., session expiration, keepalive timeouts) and ensure the application can recover or reconnect as needed. Log disconnect reasons and codes for observability. If the SDK or API has known issues (e.g., random disconnects, session update errors), document workarounds or mitigation strategies[1][3][4].\n\n5. **Update documentation**: Document the disconnect/close procedure and any relevant caveats in the integration knowledge base for future maintainers.",
        "testStrategy": "1. Write unit and integration tests to simulate normal and abnormal session lifecycles, verifying that calling the disconnect/close method reliably terminates the session and releases all resources.\n\n2. Manually test by starting and stopping multiple RealtimeSession instances, observing for memory leaks, lingering event listeners, or unhandled promise rejections.\n\n3. Simulate server-initiated disconnects (e.g., session expiration, keepalive timeout) and verify the application handles these gracefully, logs the correct reason/code, and can recover or reconnect as appropriate.\n\n4. Review logs to confirm that all disconnect events are handled and no orphaned sessions remain.\n\n5. Peer review the implementation and updated documentation for technical accuracy and clarity.",
        "status": "pending",
        "dependencies": [
          11
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Add Mute/Unmute Functionality to Voice Interface",
        "description": "Implement the ability for users to mute and unmute audio output in the voice interface without disconnecting the active session.",
        "details": "Integrate mute/unmute controls into the voice interface by leveraging the `mute()` method provided by the OpenAI Agents SDK's RealtimeSession or RealtimeTransportLayer. Ensure the mute action only affects the audio output channel (model-to-user) and does not terminate or disrupt the ongoing session. Update the UI to reflect the current mute state and allow toggling. Handle edge cases such as muting during ongoing audio playback by interrupting or pausing output as needed. Ensure that muting is session-scoped and does not affect other concurrent sessions. Reference the SDK documentation for correct usage of the `mute()` method, and ensure compatibility with both JavaScript and Python implementations if applicable. Document the mute/unmute logic and update any relevant user guides or API documentation.",
        "testStrategy": "1. Write unit tests to verify that invoking the mute and unmute controls calls the appropriate SDK methods and updates the UI state accordingly. 2. Perform integration tests by starting a session, triggering mute and unmute actions, and confirming that audio output is suppressed or resumed without disconnecting the session. 3. Manually test edge cases, such as muting during active playback and toggling mute rapidly, to ensure stability. 4. Confirm that muting one session does not affect audio output in other sessions. 5. Review logs and event streams to verify that mute/unmute actions are correctly propagated and no unexpected disconnects occur.",
        "status": "pending",
        "dependencies": [
          17
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Test and Assess Frontend State After Recent Changes",
        "description": "Evaluate the current frontend state following recent updates to determine if simple fixes are sufficient or if a full revert to a known working version is necessary.",
        "details": "After recent changes to the frontend, particularly those affecting state management, UI components, and integration with backend APIs, conduct a thorough assessment of the application's state behavior. Review logs, error reports, and user feedback to identify any regressions or unexpected behavior. Compare the current state against the previous stable version, focusing on connection status, loading states, error handling, and UI consistency. If issues are found, attempt targeted fixes for isolated problems; if the state is unstable or core functionality is broken, prepare a rollback plan to revert to the last known working version. Document all findings, proposed fixes, and the rationale for any revert decision. Ensure that any fixes or reverts are communicated to the team and tracked in the version control system.",
        "testStrategy": "1. **Manual Testing**: Interact with all major UI flows, especially voice connection, mute/unmute, and error states, to verify expected behavior. Check for consistency in loading indicators, connection status updates, and error messages. 2. **Automated Testing**: Re-run the full suite of unit, integration, and end-to-end tests, including those for API client, state management, and UI components, to detect regressions. 3. **State Inspection**: Use tools like Redux DevTools or React DevTools to inspect state transitions, action dispatches, and component re-renders, ensuring no unintended side effects from recent changes[1]. 4. **Performance Profiling**: Utilize React Profiler or similar tools to check for performance degradation related to state updates[1]. 5. **Cross-Browser Validation**: Confirm consistent behavior across supported browsers. 6. **Documentation**: Record all test results, issues found, and steps taken to resolve or revert changes. If a revert is necessary, ensure that the rollback is tested in the same manner to confirm stability.",
        "status": "pending",
        "dependencies": [
          5,
          7,
          18
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Replace Custom Audio Implementation with react-audio-voice-recorder",
        "description": "Refactor the frontend to remove the custom audio recording logic and integrate the react-audio-voice-recorder component library, enabling advanced microphone controls and professional audio handling.",
        "details": "1. Remove all custom audio recording code, including hooks, state management, and event listeners related to MediaRecorder and getUserMedia APIs.\n2. Install the react-audio-voice-recorder package and import its AudioRecorder component and/or useAudioRecorder hook as needed.\n3. Replace existing audio recording UI with the AudioRecorder component, configuring props for professional microphone controls such as noise suppression, echo cancellation, and waveform visualization (using audioTrackConstraints and showVisualizer).\n4. Ensure the onRecordingComplete callback is implemented to handle the recorded audio blob, updating the UI and backend integration as required.\n5. Support download functionality by setting downloadOnSavePress and downloadFileExtension props appropriately, ensuring cross-origin isolation if mp3/wav formats are needed.\n6. Update styles and layout to match the application's design system, using the classes prop for customization.\n7. Remove obsolete code and dependencies related to the previous audio implementation.\n8. Document the new audio recording workflow and update any related onboarding or developer guides.",
        "testStrategy": "1. Perform manual testing to verify that audio recording, saving, downloading, and playback work as expected in all supported browsers.\n2. Test advanced microphone controls (noise suppression, echo cancellation) by recording in various environments and confirming improved audio quality.\n3. Validate waveform visualization and UI responsiveness during recording.\n4. Confirm that the onRecordingComplete callback correctly processes and displays the recorded audio.\n5. Run automated frontend tests to ensure no regressions in audio recording functionality and UI integration.\n6. Check for removal of all legacy audio code and confirm no unused dependencies remain.",
        "status": "pending",
        "dependencies": [
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Research and Plan LIMI Guest Hotel UI System",
        "description": "Analyze requirements, create a detailed task breakdown, and architect a dynamic UI system for the LIMI Guest hotel platform, focusing on guest-centric features and modern usability standards.",
        "details": "1. **Requirements Analysis**: Gather and document functional and non-functional requirements for the hotel UI system by reviewing industry standards and stakeholder needs. Focus on guest management, real-time room inventory, multi-channel booking, personalized guest experiences, and efficient check-in/out processes[1][2][3][4]. Identify user roles (guests, receptionists, managers) and their specific UI needs, such as intuitive dashboards, booking flows, and administrative controls.\n\n2. **Dynamic UI Architecture Planning**: Research modern UI architectural patterns suitable for hotel management systems, such as component-based design (React/Next.js), state management strategies, and responsive layouts. Consider integration points for real-time updates (e.g., room availability, guest requests) and support for both web and mobile interfaces. Document approaches for dynamic rendering of guest preferences, smart room controls, and personalized communication panels[3].\n\n3. **Task Breakdown Creation**: Decompose the project into actionable tasks and subtasks, covering UI wireframing, component library selection (e.g., shadcn/ui), API integration points, authentication flows, accessibility compliance, and testing strategies. Map dependencies between tasks and identify milestones for iterative delivery.\n\n4. **Documentation**: Produce a comprehensive planning document outlining requirements, architectural decisions, UI flow diagrams, and the full task breakdown. Include rationale for technology choices and anticipated challenges (e.g., performance, scalability, cross-device compatibility).",
        "testStrategy": "1. Review the requirements document with stakeholders to ensure completeness and alignment with business goals.\n2. Validate the task breakdown for logical sequencing, coverage of all major UI features, and clear dependencies.\n3. Peer-review the dynamic UI architecture plan with senior engineers to confirm scalability, maintainability, and suitability for real-time hotel operations.\n4. Ensure documentation includes clear diagrams and justifications for all major decisions.\n5. Confirm that the plan addresses accessibility, performance, and cross-device compatibility requirements.",
        "status": "pending",
        "dependencies": [
          5,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Build LIMI Guest Hotel UI Core Shell with User Selection Dropdown and View State System",
        "description": "Develop the foundational UI shell for the LIMI Guest hotel platform, including a user selection dropdown and a system to determine and manage the current view state.",
        "details": "1. Scaffold the core UI shell using React, establishing a layout that supports modular content areas (e.g., header, sidebar, main content).\n2. Implement a user selection dropdown component that dynamically lists available users (guests, receptionists, managers) using a controlled React component. Ensure accessibility and keyboard navigation support. Use a flexible data structure to allow for future role expansion[1][2][3].\n3. Integrate the dropdown into the shell's header or sidebar, triggering a callback on user selection to update the active user context.\n4. Design and implement a view state determination system: maintain a central state (using React Context or Redux) that tracks the current user and determines which UI view/component should be rendered (e.g., guest dashboard, booking management, admin panel).\n5. Ensure the shell can render different child components based on the current view state, supporting future extensibility for additional views and roles.\n6. Apply consistent styling and responsive design principles to ensure usability across devices.\n7. Document component APIs and state flows for future contributors.",
        "testStrategy": "1. Unit test the user selection dropdown for correct rendering, option listing, and selection events, including edge cases (e.g., empty user list).\n2. Integration test the shell to verify that selecting a user updates the view state and renders the appropriate UI component.\n3. Manually test the UI in desktop and mobile browsers for layout, accessibility (keyboard navigation, ARIA roles), and responsiveness.\n4. Review state management logic to ensure correct view transitions and no stale state on user changes.\n5. Peer review code for modularity, extensibility, and documentation quality.",
        "status": "pending",
        "dependencies": [
          21
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Core UI Shell Layout in React",
            "description": "Establish the foundational React component structure for the LIMI Guest hotel UI shell, including modular areas for header, sidebar, and main content.",
            "dependencies": [],
            "details": "Create a main shell component using functional components and React hooks. Ensure the layout supports dynamic content insertion and future extensibility. Apply responsive design principles for usability across devices.",
            "status": "in-progress",
            "testStrategy": "Verify layout renders correctly on various screen sizes. Unit test shell component for correct area rendering."
          },
          {
            "id": 2,
            "title": "Develop Accessible User Selection Dropdown Component",
            "description": "Implement a controlled React dropdown that dynamically lists users by role (guests, receptionists, managers), supporting accessibility and keyboard navigation.",
            "dependencies": [
              "22.1"
            ],
            "details": "Use a flexible data structure for user roles to allow future expansion. Ensure ARIA attributes and keyboard navigation are implemented for accessibility compliance.",
            "status": "pending",
            "testStrategy": "Unit test dropdown for rendering, option listing, selection events, and accessibility features. Test edge cases such as empty user lists."
          },
          {
            "id": 3,
            "title": "Integrate Dropdown into Shell and Manage Active User Context",
            "description": "Embed the user selection dropdown into the shell's header or sidebar and trigger a callback to update the active user context upon selection.",
            "dependencies": [
              "22.2"
            ],
            "details": "Use React Context to manage and propagate the active user state throughout the shell. Ensure seamless integration and state updates on user selection.",
            "status": "pending",
            "testStrategy": "Integration test to verify user selection updates context and triggers correct UI changes."
          },
          {
            "id": 4,
            "title": "Implement View State Determination and Dynamic Rendering System",
            "description": "Design and build a central state system (using React Context or Redux) that tracks the current user and determines which UI view/component should be rendered.",
            "dependencies": [
              "22.3"
            ],
            "details": "Map user roles to corresponding views (e.g., guest dashboard, booking management, admin panel). Ensure the system supports future extensibility for new roles and views.",
            "status": "pending",
            "testStrategy": "Unit and integration tests for view state transitions and correct component rendering based on active user."
          },
          {
            "id": 5,
            "title": "Document Component APIs and State Flows",
            "description": "Create comprehensive documentation for all UI shell components, dropdown logic, context/state management, and view rendering flows.",
            "dependencies": [
              "22.4"
            ],
            "details": "Include API signatures, state diagrams, and integration points for future contributors. Ensure documentation is clear, up-to-date, and accessible.",
            "status": "pending",
            "testStrategy": "Manual review of documentation for completeness and clarity. Peer review by team members."
          }
        ]
      },
      {
        "id": 23,
        "title": "Deploy Supabase Docker Database and Integrate with VPS Backend for Hotel Guest Data Management",
        "description": "Deploy a self-hosted Supabase instance using Docker on the existing VPS, then integrate the backend service to manage hotel guest data through Supabase's PostgreSQL database and authentication APIs.",
        "details": "1. **Environment Setup**: Ensure Docker and Docker Compose are installed on the VPS. Clone the official Supabase Docker repository and copy the necessary configuration files to a dedicated project directory[1][3].\n2. **Configuration**: Customize the `.env` file with secure credentials (e.g., `POSTGRES_PASSWORD`, `JWT_SECRET`, `ANON_KEY`, `SERVICE_ROLE_KEY`). Replace all example values with production-grade secrets. Configure `SITE_URL` to match your VPS domain and set up SMTP credentials for email functionality if needed[1][3].\n3. **Deployment**: Start the Supabase services in detached mode using `docker compose up -d`. Verify all containers are healthy with `docker compose ps`[1][3].\n4. **Database Integration**: Modify the existing Express backend to connect to the Supabase PostgreSQL instance. Use environment variables for connection strings and credentials. Implement data models and queries for hotel guest management (e.g., check-in/check-out, room assignment, guest profiles).\n5. **Authentication Integration**: Utilize Supabase's GoTrue service for user authentication. Update the backend to handle JWT validation and role-based access control for hotel staff and guests.\n6. **API Layer**: Expose secure REST or GraphQL endpoints from the backend for frontend consumption, ensuring all sensitive operations are protected by authentication and input validation.\n7. **Security**: Never use default credentials in production. Consider placing Supabase Studio behind a reverse proxy with authentication or a VPN for additional security[1].\n8. **Documentation**: Document the deployment steps, environment variables, and integration points for future maintenance.\n\n**Example: Connecting to Supabase PostgreSQL from Node.js**\n```js\nconst { Pool } = require('pg');\nconst pool = new Pool({\n  user: process.env.DB_USER,\n  host: process.env.DB_HOST,\n  database: process.env.DB_NAME,\n  password: process.env.DB_PASSWORD,\n  port: process.env.DB_PORT,\n});\n```",
        "testStrategy": "1. **Container Health**: Verify all Supabase Docker containers are running and healthy using `docker compose ps`[3].\n2. **Database Connectivity**: Write integration tests to confirm the backend can establish a connection to the Supabase PostgreSQL database and perform basic CRUD operations on guest data.\n3. **Authentication Flow**: Test user registration, login, and JWT validation using Supabase's GoTrue API. Verify role-based access controls for different user types (guest, staff, admin).\n4. **API Endpoints**: Perform end-to-end tests on all new or modified backend endpoints, ensuring they return correct data and enforce authentication and input validation.\n5. **Security Audit**: Manually review environment variables and configuration files to ensure no default or example secrets are present. Test that sensitive endpoints are not accessible without proper authentication.\n6. **Logging and Monitoring**: Confirm that database and authentication events are logged consistently and can be monitored for errors.\n7. **Documentation Review**: Validate that deployment and integration steps are clearly documented and reproducible.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Docker Environment and Clone Supabase Repository",
            "description": "Prepare the VPS environment by ensuring Docker and Docker Compose are installed, then clone the official Supabase repository and set up the project directory structure for deployment.",
            "dependencies": [],
            "details": "Verify Docker installation on the VPS using `docker --version` and `docker compose --version`. If not installed, follow official Docker installation guides. Clone the Supabase repository with `git clone --depth 1 https://github.com/supabase/supabase`. Create a dedicated project directory `mkdir supabase-project` and copy Docker compose files using `cp -rf supabase/docker/* supabase-project` and environment template `cp supabase/docker/.env.example supabase-project/.env`.",
            "status": "pending",
            "testStrategy": "Verify Docker installation with version commands. Confirm successful repository cloning and proper file structure. Test Docker daemon is running with `docker ps`."
          },
          {
            "id": 2,
            "title": "Configure Production Environment Variables and Security Settings",
            "description": "Customize the .env configuration file with production-grade credentials, secure secrets, and hotel-specific settings for the Supabase deployment.",
            "dependencies": [
              "23.1"
            ],
            "details": "Edit the `.env` file to replace all example values with secure production credentials. Generate strong passwords for `POSTGRES_PASSWORD`, create secure JWT secrets for `JWT_SECRET`, `ANON_KEY`, and `SERVICE_ROLE_KEY`. Configure `SITE_URL` to match the VPS domain. Set up SMTP credentials for email functionality if required. Configure database connection parameters and API keys. Ensure all default credentials are replaced with production-grade secrets.",
            "status": "pending",
            "testStrategy": "Validate all environment variables are properly set and no default/example values remain. Test SMTP configuration if email functionality is enabled. Verify JWT secrets are properly formatted and secure."
          },
          {
            "id": 3,
            "title": "Deploy and Verify Supabase Docker Services",
            "description": "Start all Supabase services using Docker Compose and verify that all containers are running healthy, with proper service connectivity and functionality.",
            "dependencies": [
              "23.2"
            ],
            "details": "Navigate to the supabase-project directory and pull the latest Docker images using `docker compose pull`. Start all services in detached mode with `docker compose up -d`. Monitor the startup process and verify all containers reach a healthy state using `docker compose ps`. Check logs for any startup errors with `docker compose logs`. Ensure all required services (PostgreSQL, GoTrue, PostgREST, Realtime, etc.) are running and accessible.",
            "status": "pending",
            "testStrategy": "Verify all containers show 'running (healthy)' status. Test basic connectivity to Supabase Studio interface. Check PostgreSQL database accessibility. Monitor container logs for errors during startup."
          },
          {
            "id": 4,
            "title": "Integrate Backend Service with Supabase PostgreSQL Database",
            "description": "Modify the existing Express backend to connect to the deployed Supabase PostgreSQL instance and implement hotel guest data models and database operations.",
            "dependencies": [
              "23.3"
            ],
            "details": "Update the Express backend to use Supabase PostgreSQL connection parameters from environment variables. Install necessary database drivers (pg for PostgreSQL). Create database connection pool configuration. Design and implement data models for hotel guest management including guest profiles, room assignments, check-in/check-out records, and booking information. Implement CRUD operations for guest data management. Create database migrations and seed data if needed. Ensure proper error handling and connection management.",
            "status": "pending",
            "testStrategy": "Test database connectivity from the backend service. Verify CRUD operations work correctly for all guest data models. Test connection pooling and error recovery. Perform integration tests with sample hotel guest data."
          },
          {
            "id": 5,
            "title": "Implement Authentication Integration and API Security Layer",
            "description": "Integrate Supabase's GoTrue authentication service with the backend, implement JWT validation, role-based access control, and secure API endpoints for hotel staff and guest access.",
            "dependencies": [
              "23.4"
            ],
            "details": "Configure the backend to work with Supabase's GoTrue authentication service. Implement JWT token validation middleware for protected routes. Set up role-based access control (RBAC) to differentiate between hotel staff, managers, and guests. Create secure API endpoints for guest data operations with proper authentication checks. Implement session management and token refresh mechanisms. Add input validation and sanitization for all API endpoints. Configure CORS settings appropriately for the frontend integration.",
            "status": "pending",
            "testStrategy": "Test authentication flow with different user roles. Verify JWT validation works correctly. Test unauthorized access is properly blocked. Validate input sanitization prevents injection attacks. Test session management and token refresh functionality."
          }
        ]
      },
      {
        "id": 24,
        "title": "Implement Dynamic UI Registry System with AI Directives for Adaptive Hotel Guest Interface Components",
        "description": "Design and implement a dynamic UI registry system that enables adaptive hotel guest interface components, driven by AI directives and real-time user context.",
        "details": "Develop a server-driven UI registry that dynamically determines which interface components to render for each hotel guest, based on AI-generated directives and real-time context (e.g., guest preferences, room status, time of day). The system should expose a registry API endpoint (e.g., `/api/ui-registry`) that accepts a guest identifier and context payload, then returns a structured list of UI components (e.g., room controls, service requests, promotions) with their configuration. Integrate this with the existing React-based UI shell (Task 22) to dynamically render components. Use the Supabase PostgreSQL database (Task 23) to store component metadata, guest preferences, and AI directive history. Implement secure, role-based access to the registry endpoint, leveraging the backend’s existing auth system. Ensure the registry is extensible, allowing new component types to be added without code changes. Provide a management interface for administrators to review and override AI-driven component selections. Log all registry decisions for audit and continuous improvement.",
        "testStrategy": "1. Write unit tests for the registry API, verifying correct component selection based on mock AI directives and guest context. 2. Perform integration tests with the React UI shell, confirming that dynamically registered components render and behave as expected. 3. Test role-based access by attempting registry requests with different user roles, ensuring only authorized users can access or modify the registry. 4. Validate extensibility by registering and rendering a new custom component type via the management interface. 5. Audit log tests to confirm all registry decisions are recorded. 6. Manual testing with real guest scenarios to verify adaptive behavior and user experience.",
        "status": "pending",
        "dependencies": [
          22,
          23
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Deploy MQTT Broker and Perplexity MCP Search Agent Docker Containers for IoT Integration and Live Data",
        "description": "Deploy and configure a Mosquitto MQTT broker and a Perplexity MCP search agent as Docker containers on the VPS, enabling real-time IoT data integration and live search capabilities for the hotel platform.",
        "details": "1. **Environment Preparation**: Ensure Docker and Docker Compose are installed on the VPS. Create a dedicated directory (e.g., `/opt/stacks/mqtt`) for MQTT configuration and data persistence[1].\n2. **Mosquitto MQTT Broker Deployment**: Write a `docker-compose.yaml` file to define the Mosquitto service, mapping necessary ports (1883 for MQTT, 9001 for WebSocket) and volumes for config, data, and logs. Use the official `eclipse-mosquitto` image. Optionally, create a custom `mosquitto.conf` in the config volume for advanced settings[1][3].\n3. **Perplexity MCP Search Agent Deployment**: Define a second service in the same `docker-compose.yaml` for the Perplexity MCP search agent, ensuring it has network access to the Mosquitto broker. Configure environment variables for MQTT connection (broker host, port, credentials) and any required API keys for the search agent.\n4. **Network Configuration**: Ensure both containers are on the same Docker network for secure, low-latency communication. Expose only necessary ports to the host.\n5. **Data Persistence**: Configure volume mounts for both services to ensure data durability across container restarts.\n6. **Integration Testing**: Verify that the MQTT broker is accessible from the Perplexity MCP agent and that the agent can subscribe/publish to relevant MQTT topics. Test end-to-end IoT data flow by simulating device messages and confirming live search results.\n7. **Documentation**: Update project documentation with deployment instructions, example MQTT topics, and agent configuration details.",
        "testStrategy": "1. **Container Health**: Use `docker compose ps` to confirm both Mosquitto and Perplexity MCP containers are running and healthy.\n2. **MQTT Connectivity**: Use an MQTT client (e.g., `mosquitto_sub`, `mosquitto_pub`) to test publishing and subscribing to topics on the deployed broker.\n3. **Agent Integration**: Verify the Perplexity MCP agent can connect to the MQTT broker, subscribe to IoT data topics, and process incoming messages. Confirm the agent publishes search results or processed data to designated topics.\n4. **End-to-End Flow**: Simulate IoT device messages (e.g., sensor data) and confirm they are received by the agent, processed, and result in appropriate live search responses.\n5. **Persistence Check**: Restart containers and verify that configuration, data, and logs are preserved.\n6. **Security**: Ensure no unnecessary ports are exposed and that communication between containers is isolated from external access where possible.",
        "status": "pending",
        "dependencies": [
          23
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Integrate WebRTC Voice System into LIMI Guest SPA with Contextual AI Prompts",
        "description": "Integrate the existing WebRTC-based voice communication system into the new LIMI Guest Single Page Application (SPA), ensuring user context and hotel-specific AI prompts are incorporated into the voice session flow.",
        "details": "1. Refactor the current WebRTC voice system to operate as a modular React component compatible with the LIMI Guest SPA architecture.\n2. On session initiation, retrieve and inject user context (e.g., guest profile, room, preferences) from the SPA's state management layer.\n3. Connect the WebRTC client to the backend using ephemeral tokens, leveraging the established API integration and state management patterns (see Task 7).\n4. Integrate hotel-specific AI prompts by fetching directives from the dynamic UI registry (see Task 24) and passing them to the voice session as contextual metadata.\n5. Ensure the voice interface supports real-time updates to context and prompts, adapting the session dynamically as user or hotel state changes.\n6. Implement robust error handling, loading states, and connection status feedback consistent with SPA standards.\n7. Maintain secure handling of tokens and user data throughout the session lifecycle.\n8. Document integration points and provide usage examples for future extensibility.",
        "testStrategy": "1. Write unit tests for the voice component to verify correct initialization, context injection, and prompt handling.\n2. Perform integration tests by simulating voice sessions with varying user contexts and hotel AI directives, confirming correct prompt delivery and session adaptation.\n3. Manually test the SPA to ensure seamless voice session initiation, context-aware interactions, and real-time prompt updates.\n4. Validate error handling and connection status feedback under network failure and edge cases.\n5. Conduct cross-browser and device compatibility testing for the voice interface.",
        "status": "in-progress",
        "dependencies": [
          7,
          24
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Redesign LIMI Guest Interface for AI-Centric, Voice-First Hotel Service Interaction",
        "description": "Redesign the LIMI Guest interface to make AI-driven voice conversation the primary method for accessing and managing all hotel services, delivering a seamless, personalized, and intuitive guest experience.",
        "details": "1. Conduct user research and competitive analysis on leading AI-centric and voice-first hospitality interfaces (e.g., Alexa for Hospitality, Virgin Hotels' Lucy app) to identify best practices for conversational UX and accessibility.\n2. Define core user journeys for all major hotel services (room controls, service requests, concierge, entertainment, check-in/out) with voice as the primary interaction channel, ensuring fallback to touch/text where necessary for accessibility.\n3. Collaborate with AI and backend teams to map voice intents and conversational flows to hotel service APIs, leveraging contextual awareness, personalization engines, and service orchestration patterns[1][2][3][4].\n4. Design a modular, React-based conversational UI shell that integrates the WebRTC voice system (from Task 26), supports real-time context updates, and dynamically adapts UI components based on AI directives and guest state (leveraging the dynamic UI registry from Task 24).\n5. Implement natural language understanding (NLU) and context management hooks to maintain conversation history, personalize responses, and handle multi-turn requests (e.g., \"Can I have more towels?\" followed by \"Make it two sets, please.\")[3].\n6. Integrate visual feedback and accessibility features: display live voice transcription, intent recognition, and fallback options for guests with speech or hearing impairments.\n7. Ensure seamless orchestration between voice input, AI-driven decisioning, and hotel service execution, with robust error handling and user guidance for unsupported requests.\n8. Collaborate with branding and design teams to ensure the new interface aligns with LIMI's visual identity and hospitality standards.",
        "testStrategy": "1. Conduct end-to-end user acceptance testing (UAT) with real hotel service scenarios, verifying that all major guest tasks can be completed via voice alone, with appropriate fallbacks.\n2. Perform accessibility audits to ensure compliance with WCAG standards, including voice transcription, screen reader compatibility, and alternative input methods.\n3. Write integration tests for conversational flows, confirming correct mapping of voice intents to hotel service APIs and dynamic UI updates based on AI directives.\n4. Simulate edge cases (e.g., ambiguous requests, unsupported services, network failures) to verify robust error handling and user guidance.\n5. Gather feedback from pilot users and iterate on conversational UX, personalization, and accessibility features.",
        "status": "pending",
        "dependencies": [
          24,
          26
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Conduct Comprehensive Code Repository Review",
        "description": "Perform a thorough review of the code repository to identify current system components, redundant code, and documentation gaps.",
        "details": "Begin by cloning the latest version of the repository and mapping out all major system components, modules, and their interdependencies. Use tools such as dependency graph generators (e.g., madge) to visualize module relationships and detect circular dependencies. Review each module for redundant or obsolete code, focusing on duplicate logic, unused functions, and legacy files. Assess the quality and completeness of existing documentation, including README files, inline comments, and API docs. Create a checklist based on best practices: security (e.g., credential handling, error exposure), test coverage, performance, reusability, and scalability. Document all findings in a structured report, categorizing issues by severity and providing actionable recommendations for refactoring, removal, or documentation updates. Ensure branch protection and code review policies are in place to maintain repository health going forward.[1][2][3][4]",
        "testStrategy": "Verify that a complete inventory of system components and their relationships is produced. Confirm that all instances of redundant code are identified and documented, with clear recommendations for removal or refactoring. Review the documentation audit to ensure all major modules and APIs are accounted for, and gaps are clearly listed. Validate that the final report includes actionable recommendations and follows the established code review checklist. Optionally, present findings to the team for feedback and consensus before implementation.",
        "status": "pending",
        "dependencies": [
          15
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Deploy Redis MCP Server",
        "description": "Deploy Redis MCP Server on VPS for real-time session management.",
        "details": "Containerize and deploy the Redis MCP Server on the VPS. This will be used by the real-time AI to manage guest session state, user preferences, and cache data to improve performance and user experience. The deployment will involve creating a Dockerfile and docker-compose.yml file.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Integrate WLED Control via MQTT MCP Server",
        "description": "Integrate WLED lighting control for hotel rooms using a dedicated MQTT MCP Server. This involves deploying the server, configuring WLED devices, and enabling control through both the AI voice assistant and a guest-facing web UI.",
        "details": "The primary goal is to provide guests with seamless control over their in-room lighting. This will be achieved by deploying a Coreflux MQTT MCP Server on the VPS, which will communicate with WLED controllers in each room via the mqtt.limilighting.com broker. The real-time AI will be given a new 'tool' to interact with this MCP server, and a simple UI with preset buttons will be added to the guest web application. Security and room isolation are critical components of this task.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Deploy Coreflux MQTT MCP Server on VPS Using Docker Compose",
            "description": "Set up and deploy the Coreflux MQTT MCP Server on the designated VPS using the researched Docker Compose configuration.",
            "dependencies": [],
            "details": "Provision the VPS, install Docker and Docker Compose, and use the provided Docker Compose file to deploy the Coreflux MQTT MCP Server. Ensure the service is running and accessible on the intended network interfaces.\n<info added on 2025-09-17T03:50:38.209Z>\nDeployment completed successfully: Coreflux MQTT MCP Server is now operational and connected to mqtt.limilighting.com:1883. FastMCP server is running in SSE mode on port 8000, with external HTTP access verified from 145.79.10.35:8000. Cursor MCP configuration has been updated to use the correct port. Key troubleshooting insights: FastMCP uses a different transport API than research examples, defaults to port 8000 (not 8080), supports SSE transport (HTTP transport is not supported), and required a code modification to use mcp.run(transport=\"sse\").\n</info added on 2025-09-17T03:50:38.209Z>\n<info added on 2025-09-17T04:08:14.123Z>\nSWITCHED TO PROPER SOLUTION!\n\n✅ Replaced problematic Coreflux with official EMQX MCP Server  \n✅ Used proper Docker image: benniuji/emqx-mcp-server  \n✅ Configured with provided EMQX API credentials  \n✅ Server deployed successfully - logs show:\n   - \"EMQX message tools registered\" \n   - \"EMQX client tools registered\"\n   - \"Starting EMQX MCP Server\"\n✅ Updated Cursor config for stdio transport (proper standard)\n\nKey lessons learned:\n- Research first, deploy second  \n- Use well-documented, maintained solutions\n- Follow official Docker deployment patterns\n- Stdio transport is the MCP standard, not HTTP/SSE\n</info added on 2025-09-17T04:08:14.123Z>",
            "status": "done",
            "testStrategy": "Verify the MCP server container is running, accessible via its management port, and logs show successful startup."
          },
          {
            "id": 2,
            "title": "Configure MCP Server for Secure Connection to External MQTT Broker",
            "description": "Configure the MCP server to securely connect to mqtt.limilighting.com, including certificate management and secure authentication.",
            "dependencies": [
              "30.1"
            ],
            "details": "Update the MCP server configuration to point to mqtt.limilighting.com as the broker. Implement TLS/SSL certificate management, import CA certificates, and configure authentication credentials as required by the broker.",
            "status": "done",
            "testStrategy": "Attempt a secure connection from the MCP server to the broker and verify successful authentication and encrypted communication in logs."
          },
          {
            "id": 3,
            "title": "Configure WLED Devices with Unique MQTT Topics for Room Isolation",
            "description": "Set up each WLED device in every hotel room to connect to the broker with unique, room-specific MQTT topics to ensure secure and isolated control.",
            "dependencies": [
              "30.2"
            ],
            "details": "Access each WLED device’s web interface, enable MQTT, and assign a unique topic per room (e.g., wled/room/101). Document topic structure and ensure devices are isolated from each other.",
            "status": "done",
            "testStrategy": "Publish test messages to each room’s topic and confirm only the corresponding WLED device responds."
          },
          {
            "id": 4,
            "title": "Integrate MCP Server as a Tool in Real-Time AI Service",
            "description": "Register and expose the MCP server as a new tool within the real-time AI service, enabling tool discovery and command routing.",
            "dependencies": [
              "30.3"
            ],
            "details": "Extend the AI service’s tool registry to include the MCP server, implement tool discovery, and ensure the AI can send lighting control commands via the MCP API.\n<info added on 2025-09-17T05:05:53.813Z>\nIntegration with the MQTT MCP Server is fully operational. The AI agents can now reliably control WLED lights using the publish_mqtt_message tool, supporting ON/OFF commands and multiple effects (fx:63, 95, 110, 125). A comprehensive WLED_COMPLETE_API_REFERENCE.md has been created to document all available commands and integration details. The end-to-end control chain—AI → MCP → MQTT → WLED—has been validated in production. This subtask is now ready for the next phase: enabling real-time AI voice control of room lighting.\n</info added on 2025-09-17T05:05:53.813Z>",
            "status": "done",
            "testStrategy": "Issue test lighting commands via the AI service and confirm they are routed to the MCP server and published to the correct MQTT topics."
          },
          {
            "id": 5,
            "title": "Develop Guest Web UI Component with 5 Preset Lighting Buttons",
            "description": "Create a simple frontend UI component for the guest web app, featuring 5 preset lighting control buttons.",
            "dependencies": [
              "30.4"
            ],
            "details": "Design and implement a React (or relevant framework) component with 5 clearly labeled buttons for common lighting presets. Integrate with the app’s authentication and room context.",
            "status": "done",
            "testStrategy": "Render the component in the guest app, verify button visibility and correct labeling, and check accessibility compliance."
          },
          {
            "id": 6,
            "title": "Implement Backend Logic for Authenticated Lighting Control via UI",
            "description": "Build backend endpoints to handle UI button presses, authenticate the guest, and publish the correct MQTT command for their room.",
            "dependencies": [
              "30.5"
            ],
            "details": "Implement secure API endpoints that receive button press events, validate guest authentication and room assignment, and publish the corresponding MQTT message to the room’s topic.",
            "status": "done",
            "testStrategy": "Simulate button presses as an authenticated guest and verify correct MQTT messages are published to the appropriate room topic."
          },
          {
            "id": 7,
            "title": "Conduct End-to-End Testing of Voice and UI Lighting Control Workflow",
            "description": "Test the complete workflow from both AI voice commands and UI button presses through to WLED device response in the room.",
            "dependencies": [
              "30.6"
            ],
            "details": "Perform comprehensive tests covering voice command execution, UI interactions, backend processing, MQTT message delivery, and WLED device response. Validate security, room isolation, and guest experience.\n<info added on 2025-09-17T05:33:34.358Z>\nEND-TO-END TESTING SUCCESSFUL!\n\nAI voice commands are reliably processed through the MCP server, delivered via MQTT, and correctly executed by WLED devices in guest rooms. The confirmed working format is Topic \"room1/api\" with Message \"FX=X\" (legacy API). Successfully tested effects include Rainbow (FX=9), Pride 2015 (FX=63), Fire Flicker (FX=45), and Breathe (FX=2). Power control via \"ON\"/\"OFF\" messages to the \"room1\" topic is fully operational. All lighting controls are now available to hotel guests, and the core technical integration is complete.\n</info added on 2025-09-17T05:33:34.358Z>",
            "status": "done",
            "testStrategy": "Run test cases for both control methods in multiple rooms, confirm lights respond as expected, and verify no cross-room control or security breaches."
          }
        ]
      },
      {
        "id": 31,
        "title": "Integrate WLED Lighting Control into OpenAI Realtime Voice Agent",
        "description": "Enable guests to control in-room WLED lighting via natural voice commands processed by the OpenAI realtime voice agent, using the official realtime-next agent patterns.",
        "details": "1. Study the official OpenAI agents realtime-next example and documentation to understand the recommended architecture for tool integration and real-time voice command handling.\n2. Design and implement a new 'tool' or function within the OpenAI RealtimeAgent that can interpret lighting-related intents (e.g., 'turn on the lights', 'set lights to blue', 'dim the lights') and map them to WLED control actions.\n3. Integrate this tool with the existing WLED control layer, ensuring it communicates with the MQTT MCP Server as established in Task 30. Use secure, room-isolated messaging to prevent cross-room control.\n4. Update the agent's system prompt and instructions to include examples of lighting control, ensuring the AI understands and prioritizes these commands appropriately.\n5. Ensure the voice agent can handle real-time feedback, confirmations, and error handling (e.g., 'The lights are now blue', 'Sorry, I couldn't reach the lighting system').\n6. Follow the audio and session management patterns from the official OpenAI agents SDK, ensuring seamless voice interaction and minimal latency.\n7. Document the integration approach, including code samples and configuration for future maintainability.",
        "testStrategy": "- Write unit tests for the new WLED control tool, verifying correct intent recognition and command mapping for a variety of lighting-related voice inputs.\n- Perform integration tests by simulating voice sessions where guests issue lighting commands, confirming that the correct MQTT messages are sent and WLED devices respond as expected.\n- Manually test in a staging environment with real WLED hardware, verifying room isolation, real-time feedback, and error handling.\n- Review logs to ensure all voice-to-lighting actions are auditable and that no unauthorized cross-room control is possible.\n- Conduct regression testing to ensure existing voice agent functionality is unaffected.",
        "status": "done",
        "dependencies": [
          26,
          30
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Integrate MQTT Lighting Control with OpenAI Realtime Voice Agent",
        "description": "Study the OpenAI Agents JS realtime-next example and integrate our working MQTT lighting control as a tool in the real-time voice agent, enabling guests to control room lighting via voice commands.",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze the OpenAI Agents JS realtime-next Example Architecture",
            "description": "Study the realtime-next example and documentation to understand agent orchestration, tool integration, and real-time voice command handling patterns.",
            "dependencies": [],
            "details": "Review the OpenAI Agents SDK documentation, example code, and architectural diagrams to identify how tools are defined, registered, and invoked within the realtime-next agent framework.",
            "status": "pending",
            "testStrategy": "Document key architectural patterns and summarize how tool calls are handled in the example."
          },
          {
            "id": 2,
            "title": "Fix MCP Server SSH Connection Issue for Production",
            "description": "Resolve the SSH connection problem by configuring the system to use a direct connection to the MCP server for MQTT commands, eliminating SSH tunneling.",
            "dependencies": [
              "32.1"
            ],
            "details": "Update backend connection logic to communicate directly with the MCP server using its production endpoint, ensuring secure and reliable MQTT messaging.",
            "status": "pending",
            "testStrategy": "Verify direct connectivity to the MCP server from the backend and confirm successful MQTT command transmission."
          },
          {
            "id": 3,
            "title": "Define MQTT Lighting Control Tool Using Realtime-Next Patterns",
            "description": "Create a new tool definition for MQTT lighting control, following the tool schema and execution patterns demonstrated in the realtime-next example.",
            "dependencies": [
              "32.1",
              "32.2"
            ],
            "details": "Implement a tool object with appropriate parameters (e.g., room, action, color) and an execute function that sends MQTT commands to the MCP server.",
            "status": "pending",
            "testStrategy": "Unit test the tool definition to ensure correct parameter validation and MQTT command formatting."
          },
          {
            "id": 4,
            "title": "Integrate MQTT Lighting Tool with Voice Agent Backend",
            "description": "Register the MQTT lighting control tool with the realtime voice agent backend, enabling the agent to invoke it in response to user voice commands.",
            "dependencies": [
              "32.3"
            ],
            "details": "Update the agent configuration to include the new tool, ensuring it is accessible for tool calls during real-time sessions.",
            "status": "pending",
            "testStrategy": "Simulate backend tool calls and verify that MQTT commands are dispatched as expected."
          },
          {
            "id": 5,
            "title": "Update Agent Instructions to Include Lighting Control Capabilities",
            "description": "Modify the agent's instructions and prompt templates to inform the model about the new lighting control tool and its usage.",
            "dependencies": [
              "32.4"
            ],
            "details": "Clearly describe the tool's purpose, parameters, and example usage in the agent's instruction set to improve intent recognition and tool invocation.",
            "status": "pending",
            "testStrategy": "Review agent prompt outputs to confirm that lighting control options are suggested and invoked appropriately."
          },
          {
            "id": 6,
            "title": "Test Voice Commands for Lighting Control Functionality",
            "description": "Conduct end-to-end tests of the voice agent, issuing natural language lighting commands and verifying correct MQTT actions in the room.",
            "dependencies": [
              "32.5"
            ],
            "details": "Test a variety of voice commands (e.g., 'turn on the lights', 'set lights to blue') and confirm that the correct MQTT messages are sent and lighting responds as expected.",
            "status": "pending",
            "testStrategy": "Perform manual and automated tests, logging both voice agent responses and MQTT command outcomes."
          },
          {
            "id": 7,
            "title": "Implement Error Handling and Guest Authentication for Lighting Control",
            "description": "Add robust error handling for MQTT failures and enforce guest authentication and room isolation when processing lighting commands.",
            "dependencies": [
              "32.6"
            ],
            "details": "Ensure that only authenticated guests can control their assigned room's lighting, and that errors (e.g., MQTT timeouts) are gracefully reported to the user.",
            "status": "pending",
            "testStrategy": "Simulate authentication failures and MQTT errors, verifying that the system responds securely and informatively."
          },
          {
            "id": 8,
            "title": "Deploy and Validate the Complete Voice + Lighting System",
            "description": "Deploy the integrated system to the production environment and perform comprehensive validation of real-time voice-controlled lighting for guest rooms.",
            "dependencies": [
              "32.7"
            ],
            "details": "Monitor system performance, collect guest feedback, and ensure all components (voice agent, MQTT tool, MCP server) operate reliably in production.",
            "status": "pending",
            "testStrategy": "Run acceptance tests covering all user scenarios and monitor logs for errors or unexpected behavior post-deployment."
          }
        ]
      },
      {
        "id": 33,
        "title": "Research and Architect Perplexity MCP Server Integration for OpenAI Real-time API Agents",
        "description": "Conduct comprehensive research and provide actionable implementation guidance for integrating a Perplexity MCP server with OpenAI real-time API agents, enabling advanced real-time search capabilities such as location-based queries and nearby business discovery.",
        "details": "1. **MCP Server Setup**: Review official documentation and repositories for Perplexity MCP server implementations. Install Node.js and required dependencies, clone the MCP server repository, and configure the PERPLEXITY_API_KEY environment variable for secure API access[2][3][4][5].\n\n2. **Integration Patterns**: Analyze OpenAI agent tool integration patterns, focusing on how MCP servers expose tools (e.g., perplexity_search) compatible with OpenAI's tool format. Document how to register MCP server tools with OpenAI agents using SDKs or direct API calls[1][2][3].\n\n3. **Deployment & Connection Management**: Detail Docker containerization steps for MCP server deployment, including Dockerfile and docker-compose.yml creation. Outline best practices for VPS hosting, remote server configuration, and connection health monitoring[2][3][4].\n\n4. **API Key Management & Security**: Specify secure storage and rotation of API keys using environment variables and secrets management tools. Recommend audit logging for API key usage and access control policies[4][5].\n\n5. **Real-time Query Patterns & Response Handling**: Document how to structure real-time search queries for location-based and business discovery use cases. Provide examples of request/response formats and strategies for parsing and presenting results to users[1][2][4].\n\n6. **Error Handling & Fallbacks**: Research robust error handling mechanisms for MCP server and OpenAI agent interactions, including retries, fallback to cached results, and user feedback for degraded service[3][4].\n\n7. **Performance Optimization**: Explore techniques for optimizing real-time voice interactions, such as connection pooling, caching, and minimizing latency in API calls[1][4].\n\n8. **Testing & Validation**: Recommend using MCP Inspector and integration test suites to validate server functionality and protocol compliance[2][4].\n\nInclude code samples, configuration templates, and references to official guides where appropriate. Summarize actionable steps for replacing OpenAI's default real-time search with Perplexity-powered MCP integration.",
        "testStrategy": "1. Deploy a Perplexity MCP server in a Docker container on a VPS and verify startup and API key configuration.\n2. Register MCP server tools with OpenAI real-time agents and confirm tool discovery and invocation via test queries.\n3. Simulate real-time location-based and business discovery searches, validating response accuracy and latency.\n4. Test error handling by simulating API failures and verifying fallback mechanisms.\n5. Audit API key usage and access logs for security compliance.\n6. Use MCP Inspector and integration tests to ensure protocol adherence and robust connection management.",
        "status": "pending",
        "dependencies": [
          11,
          29
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "MCP Server Environment Setup and Configuration",
            "description": "Set up the development environment for Perplexity MCP server integration, including Node.js installation, repository cloning, dependency management, and API key configuration.",
            "dependencies": [],
            "details": "Install Node.js and npm on the target system. Clone the official Perplexity MCP server repository from GitHub. Run npm install to install all required dependencies including @modelcontextprotocol/sdk and axios. Configure the PERPLEXITY_API_KEY environment variable securely using .env files or system environment variables. Verify server startup with npm start and test basic connectivity to Perplexity API endpoints.",
            "status": "pending",
            "testStrategy": "Verify Node.js and npm versions meet requirements. Test repository cloning and dependency installation without errors. Validate API key configuration by starting the MCP server and confirming successful connection to Perplexity API. Test environment variable loading and secure storage practices."
          },
          {
            "id": 2,
            "title": "OpenAI Agent Tool Integration Pattern Analysis",
            "description": "Research and document how MCP servers expose tools in OpenAI-compatible formats, focusing on tool registration, discovery, and invocation patterns for real-time agents.",
            "dependencies": [
              "33.1"
            ],
            "details": "Analyze the Klavis AI SDK integration patterns for connecting OpenAI to MCP servers using ConnectionType.STREAMABLE_HTTP. Document how perplexity_search and other tools are formatted using ToolFormat.OPENAI. Create code templates for tool registration with OpenAI chat completions API. Research RealtimeAgent and RealtimeSession integration patterns for real-time voice interactions. Document the tool calling workflow from OpenAI agents to MCP server endpoints.",
            "status": "pending",
            "testStrategy": "Create test scenarios for tool discovery and registration with OpenAI agents. Validate tool format compatibility by testing sample tool calls. Verify real-time agent integration by simulating voice-triggered search queries. Test error handling for tool invocation failures."
          },
          {
            "id": 3,
            "title": "Docker Containerization and VPS Deployment Architecture",
            "description": "Design and implement containerized deployment strategy for the Perplexity MCP server, including Docker configuration, VPS hosting setup, and connection management.",
            "dependencies": [
              "33.1",
              "33.2"
            ],
            "details": "Create Dockerfile for the Perplexity MCP server with Node.js runtime, dependency installation, and secure environment variable handling. Design docker-compose.yml for multi-service deployment including the MCP server, reverse proxy, and monitoring services. Document VPS hosting requirements, network configuration, and firewall rules for remote MCP server access. Implement health check endpoints and connection monitoring for the deployed MCP server. Configure SSL/TLS termination and secure communication channels.",
            "status": "pending",
            "testStrategy": "Test Docker image building and container startup locally. Deploy to VPS and verify remote accessibility and API functionality. Test connection health monitoring and automatic restart capabilities. Validate SSL/TLS configuration and secure communication protocols."
          },
          {
            "id": 4,
            "title": "Security Implementation and API Key Management",
            "description": "Implement comprehensive security measures for API key management, access control, and audit logging for the Perplexity MCP server integration.",
            "dependencies": [
              "33.3"
            ],
            "details": "Design secure API key storage using environment variables, Docker secrets, or dedicated secrets management services like HashiCorp Vault. Implement API key rotation mechanisms with zero-downtime updates. Create audit logging system for all API key usage, MCP server access, and tool invocations. Establish access control policies for different user roles and rate limiting for API calls. Document security best practices for production deployment including network isolation and monitoring.",
            "status": "pending",
            "testStrategy": "Test API key rotation without service interruption. Validate audit logging captures all security-relevant events. Verify access control policies prevent unauthorized access. Test rate limiting and abuse prevention mechanisms. Conduct security review of deployed configuration."
          },
          {
            "id": 5,
            "title": "Real-time Query Optimization and Error Handling",
            "description": "Develop optimized query patterns for location-based searches and implement robust error handling with fallback mechanisms for real-time voice interactions.",
            "dependencies": [
              "33.2",
              "33.4"
            ],
            "details": "Design query templates for location-based searches, nearby business discovery, and real-time information retrieval optimized for voice interactions. Implement connection pooling and caching strategies to minimize latency in API calls. Create comprehensive error handling for MCP server failures, API timeouts, and network issues. Develop fallback mechanisms including cached results and graceful degradation. Optimize response parsing and formatting for real-time voice presentation. Implement retry logic with exponential backoff for transient failures.",
            "status": "pending",
            "testStrategy": "Test query performance under various network conditions and API load scenarios. Validate error handling by simulating API failures and network timeouts. Test fallback mechanisms ensure continuous service availability. Measure and optimize response times for real-time voice interactions. Verify retry logic prevents cascading failures."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-16T20:10:06.792Z",
      "updated": "2025-09-17T06:59:31.913Z",
      "description": "Tag created on 9/17/2025"
    }
  }
}